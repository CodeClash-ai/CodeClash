{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CodeClash Documentation","text":"<p>Welcome to CodeClash, a framework for evaluating Large Language Models (LLMs) as adaptive coding agents through competitive programming games.</p>"},{"location":"#what-is-codeclash","title":"What is CodeClash?","text":"<p>CodeClash is a platform that pits AI coding agents against each other in various programming competitions. It provides:</p> <ul> <li>Multiple Game Arenas: Support for various competitive programming games including BattleCode, BattleSnake, CoreWar, Halite (I, II, III), RoboCode, RobotRumble, and HuskyBench</li> <li>Tournament System: Flexible tournament configurations for single-player and player-vs-player (PvP) competitions</li> <li>LLM Integration: Easy integration with various LLM providers for agent implementations</li> <li>Interactive Viewer: Web-based trajectory viewer to analyze game results and agent behavior</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#multiple-game-arenas","title":"Multiple Game Arenas","text":"<p>Each game presents unique challenges requiring different coding strategies:</p> <ul> <li>BattleCode: Real-time strategy game</li> <li>BattleSnake: Multiplayer snake game</li> <li>CoreWar: Memory-based combat programming</li> <li>Halite: Resource collection and strategy</li> <li>RoboCode: Robot combat programming</li> <li>RobotRumble: Rust-based robot battles</li> <li>HuskyBench: Custom benchmarking scenarios</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Quick Start Guide - Get started in minutes</li> <li>API Reference - Detailed API documentation</li> <li>GitHub Repository - Source code and issues</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<p>If you encounter any issues or have questions:</p> <ol> <li>Review the API documentation</li> <li>Open an issue on GitHub</li> </ol>"},{"location":"#citation","title":"Citation","text":"<p>If you use CodeClash in your research, please cite:</p> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"_footer/","title":"footer","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Get up and running with CodeClash in minutes!</p>"},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>Docker (for running games in containers)</li> <li>Git</li> <li>Conda (recommended)</li> </ul>"},{"location":"quickstart/#setup","title":"Setup","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/emagedoc/CodeClash.git\ncd CodeClash\n</code></pre> <ol> <li>Create a conda environment:</li> </ol> <pre><code>conda create -n codeclash python=3.10 -y\nconda activate codeclash\n</code></pre> <ol> <li>Install the package:</li> </ol> <pre><code>pip install -e '.[dev]'\npre-commit install\n</code></pre> <ol> <li>Set up environment variables:</li> </ol> <p>Create a <code>.env</code> file in the project root:</p> <pre><code>GITHUB_TOKEN=your_github_token_here\n</code></pre> <p>Note</p> <p>You need a GitHub token with access permissions for the organization to pull game repositories.</p>"},{"location":"quickstart/#running-your-first-tournament","title":"Running Your First Tournament","text":""},{"location":"quickstart/#basic-pvp-tournament","title":"Basic PvP Tournament","text":"<p>Run a player-vs-player tournament with 2+ models competing:</p> <pre><code>python main.py configs/pvp/battlecode.yaml\n</code></pre>"},{"location":"quickstart/#available-games","title":"Available Games","text":"<p>Try different games:</p> <pre><code># BattleSnake\npython main.py configs/pvp/battlesnake.yaml\n\n# RoboCode\npython main.py configs/pvp/robocode.yaml\n\n# RobotRumble\npython main.py configs/pvp/robotrumble.yaml\n\n# CoreWar\npython main.py configs/pvp/corewar.yaml\n</code></pre>"},{"location":"quickstart/#viewing-results","title":"Viewing Results","text":"<p>After running a tournament, view the results using the interactive viewer:</p> <pre><code>python run_viewer.py\n</code></pre> <p>The viewer will start a local web server. Open your browser to view:</p> <ul> <li>Game trajectories</li> <li>Agent performance metrics</li> <li>Round-by-round analysis</li> <li>Code changes over time</li> </ul> <p>Use the <code>-d</code> flag to specify a custom log directory:</p> <pre><code>python run_viewer.py -d path/to/logs\n</code></pre>"},{"location":"quickstart/#configuration","title":"Configuration","text":"<p>Tournament configurations are stored in YAML files under <code>configs/</code>. Here's a basic structure:</p> <pre><code>game:\n  name: BattleCode\n  rounds: 10\n  sims_per_round: 3\n\nplayers:\n  - name: Agent1\n    model: gpt-4\n  - name: Agent2\n    model: claude-3-opus\n</code></pre> <p>See Running Tournaments for detailed configuration options.</p>"},{"location":"quickstart/#faq","title":"FAQ","text":""},{"location":"quickstart/#how-do-i-add-a-new-llm-provider","title":"How do I add a new LLM provider?","text":"<p>Configure your model in the agent configuration section of your YAML file. CodeClash supports any provider compatible with LiteLLM.</p>"},{"location":"quickstart/#where-are-logs-stored","title":"Where are logs stored?","text":"<p>By default, logs are stored in the <code>logs/</code> directory at the project root. Each tournament creates a subdirectory with a unique ID.</p>"},{"location":"quickstart/#can-i-create-custom-games","title":"Can I create custom games?","text":"<p>Yes! Extend the <code>CodeGame</code> abstract class. See the API Reference for details.</p>"},{"location":"quickstart/#how-do-i-debug-agent-behavior","title":"How do I debug agent behavior?","text":"<p>Use the trajectory viewer to step through each round and see:</p> <ul> <li>Code changes made by the agent</li> <li>Game logs and outputs</li> <li>Performance metrics</li> <li>Error messages</li> </ul>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about tournaments</li> <li>Explore the API</li> <li>Build custom agents</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/","title":"API Reference","text":"<p>Complete API documentation for CodeClash.</p>"},{"location":"reference/#overview","title":"Overview","text":"<p>CodeClash provides a modular architecture with three main components:</p>"},{"location":"reference/#arenas","title":"Arenas","text":"<p>Game environments where agents compete. Each arena implements the <code>CodeGame</code> abstract class and provides:</p> <ul> <li>Code validation</li> <li>Game execution</li> <li>Result determination</li> </ul> <p>Available arenas: - BattleCode - BattleSnake - CoreWar - Halite, Halite II, Halite III - HuskyBench - RoboCode - RobotRumble</p>"},{"location":"reference/#players","title":"Players","text":"<p>Agents that write code to compete in games. Players extend the <code>Player</code> abstract class.</p> <p>Available implementations: - Mini-SWE-Agent - LLM-powered coding agent - Dummy Agent - Testing agent</p>"},{"location":"reference/#tournaments","title":"Tournaments","text":"<p>Orchestrate competitions between multiple players across rounds.</p> <p>Tournament types: - AbstractTournament - Base tournament class - PvP - Player vs player tournaments - SinglePlayer - Player against itself</p>"},{"location":"reference/#core-concepts","title":"Core Concepts","text":""},{"location":"reference/#game-flow","title":"Game Flow","text":"<pre><code>1. Tournament creates Game and Players\n2. For each round:\n   a. Players receive game state/logs\n   b. Players modify their code\n   c. Game validates player code\n   d. Game executes with all valid players\n   e. Results are recorded\n3. Winner determined by cumulative scores\n</code></pre>"},{"location":"reference/#docker-architecture","title":"Docker Architecture","text":"<p>Each component runs in isolated Docker containers:</p> <ul> <li>Game Container: Runs the game engine</li> <li>Player Containers: Provide isolated environments for agent code</li> </ul> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/battlecode/","title":"BattleCode","text":"<p>Real-time strategy game where robots compete to gather resources and destroy opponents.</p>"},{"location":"reference/arenas/battlecode/#overview","title":"Overview","text":"<p>BattleCode is a programming competition where players write Java code to control teams of robots in a real-time strategy game.</p>"},{"location":"reference/arenas/battlecode/#resources","title":"Resources","text":"<ul> <li>BattleCode Official Site</li> </ul>"},{"location":"reference/arenas/battlecode/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame","title":"codeclash.games.battlecode.battlecode.BattleCodeGame","text":"<pre><code>BattleCodeGame(config, **kwargs)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/battlecode/battlecode.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    assert len(config[\"players\"]) == 2, \"BattleCode is a two-player game\"\n    self.run_cmd_round: str = \"python run.py run\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" --{arg}\"\n        else:\n            self.run_cmd_round += f\" --{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'BattleCode'\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = 'Battlecode 25 throws you into a real-time strategy showdown where your Python bot pilots a team of specialized robots\u2014Soldiers, Moppers, Splashers\u2014alongside towers that spawn units or generate resources.\\nYour mission: paint over 70% of the map (or eliminate the enemy) by coordinating cleanups, area cover, and tower-building through tight bytecode budgets and clever unit synergy.'\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {'maps': 'quack'}\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'src/mysubmission'\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.run_cmd_round","title":"run_cmd_round  <code>instance-attribute</code>","text":"<pre><code>run_cmd_round: str = 'python run.py run'\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/battlecode/battlecode.py</code> <pre><code>def execute_round(self, agents: list[Player]):\n    for agent in agents:\n        src, dest = f\"/{agent.name}/src/{BC_FOLDER}/\", str(DIR_WORK / \"src\" / agent.name)\n        self.environment.execute(f\"cp -r {src} {dest}\")\n    args = [f\"--p{idx + 1}-dir src --p{idx + 1} {agent.name}\" for idx, agent in enumerate(agents)]\n    cmd = f\"{self.run_cmd_round} {' '.join(args)}\"\n    self.logger.info(f\"Running game: {cmd}\")\n\n    with ThreadPoolExecutor(5) as executor:\n        # Submit all simulations to the thread pool\n        futures = [\n            executor.submit(self._run_single_simulation, agents, idx, cmd)\n            for idx in range(self.game_config[\"sims_per_round\"])\n        ]\n        # Collect results as they complete\n        for future in tqdm(as_completed(futures), total=len(futures), desc=\"Simulations\"):\n            future.result()\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/battlecode/battlecode.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    scores = defaultdict(int)\n    for idx in range(self.game_config[\"sims_per_round\"]):\n        with open(self.log_round(round_num) / BC_LOG.format(idx=idx)) as f:\n            lines = f.read().strip().split(\"\\n\")\n        # Get the third-to-last line which contains the winner info\n        assert len(lines) &gt;= 3, \"Log file does not contain enough lines to determine winner\"\n        winner_line = lines[-3]\n        reason_line = lines[-2]\n        match = re.search(r\"\\s\\((.*)\\)\\swins\\s\\(\", winner_line)\n        if match and reason_line != BC_TIE:\n            winner_key = match.group(1)\n            # Map A/B to actual agent names (much closer to original code)\n            winner = {\"A\": agents[0].name, \"B\": agents[1].name}.get(winner_key, RESULT_TIE)\n            scores[winner] += 1\n        else:\n            winner = RESULT_TIE\n\n    stats.winner = max(scores, key=scores.get)\n    stats.scores = scores\n    for player, score in stats.scores.items():\n        stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/battlecode/#codeclash.games.battlecode.battlecode.BattleCodeGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/battlecode/battlecode.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    if BC_FOLDER not in agent.environment.execute(\"ls src\")[\"output\"]:\n        return False, f\"There should be a `src/{BC_FOLDER}/` directory\"\n    if \"bot.py\" not in agent.environment.execute(f\"ls src/{BC_FOLDER}\")[\"output\"]:\n        return False, f\"There should be a `src/{BC_FOLDER}/bot.py` file\"\n    bot_content = agent.environment.execute(f\"cat src/{BC_FOLDER}/bot.py\")[\"output\"].splitlines()\n    if \"def turn():\" not in bot_content:\n        return False, f\"There should be a `turn()` function implemented in `src/{BC_FOLDER}/bot.py`\"\n    return True, None\n</code></pre>"},{"location":"reference/arenas/battlesnake/","title":"BattleSnake","text":"<p>Multiplayer snake game where snakes compete to be the last survivor.</p>"},{"location":"reference/arenas/battlesnake/#overview","title":"Overview","text":"<p>BattleSnake is a multi-player version of the classic snake game. Players implement an HTTP server that responds to game state with movement decisions.</p>"},{"location":"reference/arenas/battlesnake/#game-rules","title":"Game Rules","text":"<ul> <li>Snakes move on a grid</li> <li>Eat food to grow longer</li> <li>Avoid walls and other snakes</li> <li>Last snake standing wins</li> </ul>"},{"location":"reference/arenas/battlesnake/#submission-format","title":"Submission Format","text":"<p>Players must implement an HTTP server with specific endpoints:</p> <ul> <li><code>GET /</code>: Return snake metadata</li> <li><code>POST /start</code>: Handle game start</li> <li><code>POST /move</code>: Return movement decision</li> <li><code>POST /end</code>: Handle game end</li> </ul>"},{"location":"reference/arenas/battlesnake/#configuration-example","title":"Configuration Example","text":"<pre><code>game:\n  name: BattleSnake\n  rounds: 10\n  sims_per_round: 5\n  timeout: 300\n\nplayers:\n  - name: Snake1\n    model: gpt-4\n  - name: Snake2\n    model: claude-3\n</code></pre>"},{"location":"reference/arenas/battlesnake/#resources","title":"Resources","text":"<ul> <li>BattleSnake Official Site</li> <li>API Documentation</li> </ul>"},{"location":"reference/arenas/battlesnake/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame","title":"codeclash.games.battlesnake.battlesnake.BattleSnakeGame","text":"<pre><code>BattleSnakeGame(config, **kwargs)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/battlesnake/battlesnake.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    self.run_cmd_round: str = \"./battlesnake play\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" --{arg}\"\n        else:\n            self.run_cmd_round += f\" --{arg} {val}\"\n    self._failed_to_start_player = []\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'BattleSnake'\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'main.py'\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = 'Your bot (`main.py`) controls a snake on a grid-based board.\\nSnakes collect food, avoid collisions, and try to outlast their opponents.'\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {'width': 11, 'height': 11, 'browser': False}\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.run_cmd_round","title":"run_cmd_round  <code>instance-attribute</code>","text":"<pre><code>run_cmd_round: str = './battlesnake play'\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/battlesnake/battlesnake.py</code> <pre><code>def execute_round(self, agents: list[Player]):\n    self._failed_to_start_player = []\n    assert len(agents) &gt; 1, \"Battlesnake requires at least two players\"\n    self.logger.debug(\"Starting game servers\")\n    player2port = {}\n    for idx, agent in enumerate(agents):\n        port = 8001 + idx\n        player2port[agent.name] = port\n        # Surprisingly slow despite using &amp;\n        # Start server in background - just add &amp; to run in background!\n        self.environment.execute(f\"PORT={port} python {self.submission} &amp;\", cwd=f\"/{agent.name}\")\n\n    self.logger.debug(f\"Waiting for ports: {player2port}\")\n    available_ports = self._wait_for_ports(list(player2port.values()))\n\n    if not available_ports:\n        raise RuntimeError(\"All games failed to start\")\n\n    if len(available_ports) == 1:\n        missing_ports = set(player2port.values()) - set(available_ports)\n        missing_player = next(player for player, port in player2port.items() if port in missing_ports)\n        self.logger.warning(f\"Player {missing_player} failed to start\")\n        self._failed_to_start_player.append(missing_player)\n        return\n\n    if len(available_ports) &lt; len(agents):\n        raise RuntimeError(f\"Only {len(available_ports)} players started: {available_ports}\")\n\n    self.logger.debug(\"All ports are ready\")\n\n    try:\n        self.logger.info(f\"Running game with players: {list(player2port.keys())}\")\n\n        # Use ThreadPoolExecutor for parallel execution\n        with ThreadPoolExecutor(20) as executor:\n            # Submit all simulations to the thread pool\n            futures = [\n                executor.submit(self._run_single_simulation, player2port, idx)\n                for idx in range(self.game_config[\"sims_per_round\"])\n            ]\n\n            # Collect results as they complete\n            for future in tqdm(as_completed(futures), total=len(futures)):\n                future.result()\n    finally:\n        # Kill all python servers when done\n        self.environment.execute(f\"pkill -f 'python {self.submission}' || true\")\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/battlesnake/battlesnake.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    scores = defaultdict(int)\n    available_players = [player.name for player in agents if player.name not in self._failed_to_start_player]\n    if len(available_players) &gt; 1:\n        # We ran the game\n        for idx in range(self.game_config[\"sims_per_round\"]):\n            try:\n                with open(self.log_round(round_num) / f\"sim_{idx}.jsonl\") as f:\n                    lines = f.read().strip().split(\"\\n\")\n                    results = json.loads(lines[-1])  # Get the last line which contains the game result\n                    winner = RESULT_TIE if results[\"isDraw\"] else results[\"winnerName\"]\n                    scores[winner] += 1\n            except FileNotFoundError:\n                self.logger.warning(f\"Simulation {idx} not found, skipping\")\n            except json.JSONDecodeError:\n                self.logger.warning(f\"Simulation {idx} is not a valid JSON, skipping\")\n    else:\n        self.logger.warning(f\"Only one player ({available_players[0]}) started, giving them the win\")\n        # We didn't run a game, so we just give the one player the win\n        available_player = available_players[0]\n        scores = {available_player: self.game_config[\"sims_per_round\"]}\n\n    winner = max(scores, key=scores.get)\n    winner = RESULT_TIE if list(scores.values()).count(scores[winner]) &gt; 1 else winner\n    stats.winner = winner\n    stats.scores = scores\n    for player, score in scores.items():\n        if player != RESULT_TIE:\n            stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/battlesnake/#codeclash.games.battlesnake.battlesnake.BattleSnakeGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/battlesnake/battlesnake.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    if self.submission not in agent.environment.execute(\"ls\")[\"output\"]:\n        return False, f\"No {self.submission} file found in the root directory\"\n    # note: no longer calling splitlines\n    bot_content = agent.environment.execute(f\"cat {self.submission}\")[\"output\"]\n    error_msg = []\n    for func in [\n        \"def info(\",\n        \"def start(\",\n        \"def end(\",\n        \"def move(\",\n    ]:\n        if func not in bot_content:\n            error_msg.append(f\"There should be a `{func}` function implemented in `{self.submission}`\")\n    if len(error_msg) &gt; 0:\n        return False, \"\\n\".join(error_msg + [\"Don't change the function signatures!\"])\n    return True, None\n</code></pre>"},{"location":"reference/arenas/corewar/","title":"CoreWar","text":"<p>Memory-based combat programming game where programs battle for control of virtual memory.</p>"},{"location":"reference/arenas/corewar/#overview","title":"Overview","text":"<p>CoreWar is a programming game where players write programs in Redcode assembly language that battle for control of a virtual computer's memory.</p>"},{"location":"reference/arenas/corewar/#game-rules","title":"Game Rules","text":"<ul> <li>Programs written in Redcode assembly</li> <li>Battle in shared virtual memory space</li> <li>Try to overwrite or disrupt opponent's code</li> <li>Last running program wins</li> </ul>"},{"location":"reference/arenas/corewar/#configuration-example","title":"Configuration Example","text":"<pre><code>game:\n  name: CoreWar\n  rounds: 10\n  sims_per_round: 10\n  timeout: 180\n\nplayers:\n  - name: Warrior1\n    model: gpt-4\n  - name: Warrior2\n    model: claude-3\n</code></pre>"},{"location":"reference/arenas/corewar/#resources","title":"Resources","text":"<ul> <li>CoreWar Documentation</li> </ul>"},{"location":"reference/arenas/corewar/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame","title":"codeclash.games.corewar.corewar.CoreWarGame","text":"<pre><code>CoreWarGame(config, **kwargs)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/corewar/corewar.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    self.run_cmd_round: str = \"./src/pmars\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" -{arg}\"\n        else:\n            self.run_cmd_round += f\" -{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'CoreWar'\n</code></pre>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = 'CoreWar is a programming battle where you write \"warriors\" in an assembly-like language called Redcode to compete within a virtual machine (MARS), aiming to eliminate your rivals by making their code self-terminate.\\nVictory comes from crafting clever tactics\u2014replicators, scanners, bombers\u2014that exploit memory layout and instruction timing to control the core.'\n</code></pre>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'warrior.red'\n</code></pre>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame.run_cmd_round","title":"run_cmd_round  <code>instance-attribute</code>","text":"<pre><code>run_cmd_round: str = './src/pmars'\n</code></pre>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/corewar/corewar.py</code> <pre><code>def execute_round(self, agents: list[Player]):\n    args = [f\"/{agent.name}/{self.submission}\" for agent in agents]\n    cmd = (\n        f\"{self.run_cmd_round} {shlex.join(args)} \"\n        f\"-r {self.game_config['sims_per_round']} \"\n        f\"&gt; {self.log_env / COREWAR_LOG};\"\n    )\n    self.logger.info(f\"Running game: {cmd}\")\n    response = self.environment.execute(cmd)\n    assert response[\"returncode\"] == 0, response\n</code></pre>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/corewar/corewar.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    with open(self.log_round(round_num) / COREWAR_LOG) as f:\n        result_output = f.read()\n    self.logger.debug(f\"Determining winner from result output: {result_output}\")\n    scores = []\n    n = len(agents) * 2\n    lines = result_output.strip().split(\"\\n\")\n\n    # Get the last n lines which contain the scores (closer to original)\n    relevant_lines = lines[-n:] if len(lines) &gt;= n else lines\n    relevant_lines = [l for l in relevant_lines if len(l.strip()) &gt; 0]\n    self.logger.debug(f\"Relevant lines for scoring: {relevant_lines}\")\n\n    # Go through each line; we assume score position is correlated with agent index\n    for line in relevant_lines:\n        match = re.search(r\".*\\sby\\s.*\\sscores\\s(\\d+)\", line)\n        if match:\n            score = int(match.group(1))\n            scores.append(score)\n\n    if scores:\n        if len(scores) != len(agents):\n            self.logger.error(f\"Have {len(scores)} scores but {len(agents)} agents\")\n        stats.winner = agents[scores.index(max(scores))].name\n        stats.scores = {agent.name: score for agent, score in zip(agents, scores)}\n    else:\n        self.logger.debug(\"No scores found, returning unknown\")\n        stats.winner = \"unknown\"\n        stats.scores = {agent.name: 0 for agent in agents}\n\n    for player, score in stats.scores.items():\n        stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/corewar/#codeclash.games.corewar.corewar.CoreWarGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/corewar/corewar.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    if self.submission not in agent.environment.execute(\"ls\")[\"output\"]:\n        return False, f\"There should be a `{self.submission}` file\"\n    # Play game against a simple default bot to ensure it runs\n    test_run_cmd = f\"{self.run_cmd_round} {self.submission} /home/dwarf.red\"\n    test_run = agent.environment.execute(test_run_cmd, timeout=60)[\"output\"]\n    if any([l.startswith(\"Error\") for l in test_run.split(\"\\n\")]):\n        return False, f\"The `{self.submission}` file is malformed (Ran `{test_run_cmd}`):\\n{test_run}\"\n    return True, None\n</code></pre>"},{"location":"reference/arenas/dummy/","title":"DummyGame","text":"<p>Simple test game for development and debugging.</p>"},{"location":"reference/arenas/dummy/#overview","title":"Overview","text":"<p>DummyGame is a minimal game implementation used for testing the CodeClash framework.</p>"},{"location":"reference/arenas/dummy/#implementation","title":"Implementation","text":""},{"location":"reference/arenas/dummy/#codeclash.games.dummy.dummy_game.DummyGame","title":"codeclash.games.dummy.dummy_game.DummyGame","text":"<pre><code>DummyGame(config: dict, *, tournament_id: str, local_output_dir: Path, keep_containers: bool = False)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/game.py</code> <pre><code>def __init__(self, config: dict, *, tournament_id: str, local_output_dir: Path, keep_containers: bool = False):\n    \"\"\"The CodeGame class is responsible for running games, i.e., taking a list of code\n    from different agents/players and running them against each other.\n    It also provides the environments for the game and agents to run in.\n\n    The central method is `run_round`, which takes a list of agents and returns the winner of the round.\n\n    At the end of the the tournament, run the `end` method to clean up the game and agents and write the metadata.\n\n    Args:\n        config: The overall config for the tournament.\n        tournament_id: The id of the tournament.\n        local_output_dir: The host/local directory to write logs to.\n        keep_containers: Do not remove containers after games/agent finish.\n    \"\"\"\n    self.url_gh: str = f\"git@github.com:{GH_ORG}/{self.name}.git\"\n    self.artifacts: list[Path] = []\n    \"\"\"Artifact objects that we might want to clean up after the game.\"\"\"\n    self.config: dict = config\n    self._keep_containers: bool = keep_containers\n    self._metadata: dict = {\n        \"name\": self.name,\n        \"config\": self.config[\"game\"],\n        \"game_id\": tournament_id,\n        \"created_timestamp\": int(time.time()),\n    }\n    self.log_env: Path = DIR_LOGS\n    self.log_local: Path = local_output_dir\n    self.logger = get_logger(self.name, log_path=self.log_local / \"game.log\", emoji=\"\ud83c\udfd3\")\n    self.environment: DockerEnvironment = self.get_environment()\n    \"\"\"The running docker environment for executing the game\"\"\"\n</code></pre>"},{"location":"reference/arenas/dummy/#codeclash.games.dummy.dummy_game.DummyGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'DummyGame'\n</code></pre>"},{"location":"reference/arenas/dummy/#codeclash.games.dummy.dummy_game.DummyGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = 'WARNING: This is a dummy game meant for testing the CodeClash infrastructure. It does not represent a real game.'\n</code></pre>"},{"location":"reference/arenas/dummy/#codeclash.games.dummy.dummy_game.DummyGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'main.py'\n</code></pre>"},{"location":"reference/arenas/dummy/#codeclash.games.dummy.dummy_game.DummyGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player]) -&gt; None\n</code></pre> Source code in <code>codeclash/games/dummy/dummy_game.py</code> <pre><code>def execute_round(self, agents: list[Player]) -&gt; None:\n    args = [f\"/{agent.name}/{self.submission}\" for agent in agents]\n    cmd = f\"python engine.py {' '.join(args)} -r {self.game_config['sims_per_round']} &gt; {self.log_env / DUMMY_LOG};\"\n    self.logger.info(f\"Running game: {cmd}\")\n    assert_zero_exit_code(self.environment.execute(cmd))\n</code></pre>"},{"location":"reference/arenas/dummy/#codeclash.games.dummy.dummy_game.DummyGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/dummy/dummy_game.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    with open(self.log_round(round_num) / DUMMY_LOG) as f:\n        round_log = f.read()\n    lines = round_log.split(\"FINAL_RESULTS\")[-1].splitlines()\n\n    scores = {}\n    for line in lines:\n        match = re.search(r\"Bot\\_(\\d)\\_main:\\s(\\d+)\\srounds\\swon\", line)\n        if match:\n            bot_id = match.group(1)\n            rounds_won = int(match.group(2))\n            scores[agents[int(bot_id) - 1].name] = rounds_won\n\n    stats.winner = max(scores, key=scores.get) if scores else \"unknown\"\n    stats.scores = scores\n    for player, score in scores.items():\n        stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/dummy/#codeclash.games.dummy.dummy_game.DummyGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/dummy/dummy_game.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    # TODO: implement more checks\n    return True, None\n</code></pre>"},{"location":"reference/arenas/dummy/#usage","title":"Usage","text":"<p>Useful for: - Testing tournament infrastructure - Debugging agent implementations - Quick validation of configurations</p>"},{"location":"reference/arenas/dummy/#configuration-example","title":"Configuration Example","text":"<pre><code>game:\n  name: DummyGame\n  rounds: 3\n  sims_per_round: 1\n\nplayers:\n  - name: TestAgent\n    model: gpt-4\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/game/","title":"CodeGame (Abstract Base)","text":"<p>The <code>CodeGame</code> class is the abstract base class for all game arenas in CodeClash.</p>"},{"location":"reference/arenas/game/#overview","title":"Overview","text":"<p>Every game in CodeClash extends <code>CodeGame</code> and implements three key methods:</p> <ol> <li><code>validate_code()</code>: Verify that player submissions are valid</li> <li><code>execute_round()</code>: Run the actual game</li> <li><code>get_results()</code>: Determine winners and scores</li> </ol>"},{"location":"reference/arenas/game/#key-concepts","title":"Key Concepts","text":""},{"location":"reference/arenas/game/#game-lifecycle","title":"Game Lifecycle","text":"<ol> <li>Initialization: Game container is created with Docker</li> <li>Round Execution: For each round:</li> <li>Pre-round setup (copy player code)</li> <li>Validation (check all submissions)</li> <li>Execution (run the game)</li> <li>Results (determine winner)</li> <li>Post-round (save logs)</li> <li>Cleanup: Remove containers and artifacts</li> </ol>"},{"location":"reference/arenas/game/#docker-integration","title":"Docker Integration","text":"<p>Each game runs in its own Docker container with:</p> <ul> <li>Game engine installed</li> <li>Git repository initialized</li> <li>Player code copied in</li> </ul>"},{"location":"reference/arenas/game/#class-reference","title":"Class Reference","text":""},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame","title":"codeclash.games.game.CodeGame","text":"<pre><code>CodeGame(config: dict, *, tournament_id: str, local_output_dir: Path, keep_containers: bool = False)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>The CodeGame class is responsible for running games, i.e., taking a list of code from different agents/players and running them against each other. It also provides the environments for the game and agents to run in.</p> <p>The central method is <code>run_round</code>, which takes a list of agents and returns the winner of the round.</p> <p>At the end of the the tournament, run the <code>end</code> method to clean up the game and agents and write the metadata.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The overall config for the tournament.</p> required <code>tournament_id</code> <code>str</code> <p>The id of the tournament.</p> required <code>local_output_dir</code> <code>Path</code> <p>The host/local directory to write logs to.</p> required <code>keep_containers</code> <code>bool</code> <p>Do not remove containers after games/agent finish.</p> <code>False</code> Source code in <code>codeclash/games/game.py</code> <pre><code>def __init__(self, config: dict, *, tournament_id: str, local_output_dir: Path, keep_containers: bool = False):\n    \"\"\"The CodeGame class is responsible for running games, i.e., taking a list of code\n    from different agents/players and running them against each other.\n    It also provides the environments for the game and agents to run in.\n\n    The central method is `run_round`, which takes a list of agents and returns the winner of the round.\n\n    At the end of the the tournament, run the `end` method to clean up the game and agents and write the metadata.\n\n    Args:\n        config: The overall config for the tournament.\n        tournament_id: The id of the tournament.\n        local_output_dir: The host/local directory to write logs to.\n        keep_containers: Do not remove containers after games/agent finish.\n    \"\"\"\n    self.url_gh: str = f\"git@github.com:{GH_ORG}/{self.name}.git\"\n    self.artifacts: list[Path] = []\n    \"\"\"Artifact objects that we might want to clean up after the game.\"\"\"\n    self.config: dict = config\n    self._keep_containers: bool = keep_containers\n    self._metadata: dict = {\n        \"name\": self.name,\n        \"config\": self.config[\"game\"],\n        \"game_id\": tournament_id,\n        \"created_timestamp\": int(time.time()),\n    }\n    self.log_env: Path = DIR_LOGS\n    self.log_local: Path = local_output_dir\n    self.logger = get_logger(self.name, log_path=self.log_local / \"game.log\", emoji=\"\ud83c\udfd3\")\n    self.environment: DockerEnvironment = self.get_environment()\n    \"\"\"The running docker environment for executing the game\"\"\"\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.description","title":"description  <code>instance-attribute</code>","text":"<pre><code>description: str\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {}\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.submission","title":"submission  <code>instance-attribute</code>","text":"<pre><code>submission: str\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.url_gh","title":"url_gh  <code>instance-attribute</code>","text":"<pre><code>url_gh: str = f'git@github.com:{GH_ORG}/{name}.git'\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.artifacts","title":"artifacts  <code>instance-attribute</code>","text":"<pre><code>artifacts: list[Path] = []\n</code></pre> <p>Artifact objects that we might want to clean up after the game.</p>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: dict = config\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.log_env","title":"log_env  <code>instance-attribute</code>","text":"<pre><code>log_env: Path = DIR_LOGS\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.log_local","title":"log_local  <code>instance-attribute</code>","text":"<pre><code>log_local: Path = local_output_dir\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger(name, log_path=log_local / 'game.log', emoji='\ud83c\udfd3')\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.environment","title":"environment  <code>instance-attribute</code>","text":"<pre><code>environment: DockerEnvironment = get_environment()\n</code></pre> <p>The running docker environment for executing the game</p>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.game_config","title":"game_config  <code>property</code>","text":"<pre><code>game_config: dict\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.game_id","title":"game_id  <code>property</code>","text":"<pre><code>game_id: str\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.image_name","title":"image_name  <code>property</code>","text":"<pre><code>image_name: str\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.build_image","title":"build_image","text":"<pre><code>build_image()\n</code></pre> <p>Build a Docker image for the game using the Dockerfile in the codebase. If running in AWS, pull the image from the AWS Docker registry instead.</p> Source code in <code>codeclash/games/game.py</code> <pre><code>def build_image(self):\n    \"\"\"\n    Build a Docker image for the game using the Dockerfile in the codebase.\n    If running in AWS, pull the image from the AWS Docker registry instead.\n    \"\"\"\n    if is_running_in_aws_batch():\n        pull_game_container_aws_ecr(game_name=self.name, image_name=self.image_name, logger=self.logger)\n\n    # Check if container exists using subprocess\n    self.logger.debug(f\"Checking if container {self.image_name} exists\")\n    result = subprocess.run(\n        f\"docker images -q {self.image_name}\",\n        shell=True,\n        capture_output=True,\n        text=True,\n    )\n    if result.stdout.strip():\n        self.logger.debug(f\"Container {self.image_name} exists\")\n        return\n\n    self.logger.info(\n        f\"Building Docker image {self.image_name}. This may take 1-5 minutes and only work on Linux for some games.\"\n    )\n    result = subprocess.run(\n        (\n            \"export $(cat .env | xargs);\"\n            f\"docker build --no-cache --build-arg GITHUB_TOKEN=$GITHUB_TOKEN -t {self.image_name} -f docker/{self.name}.Dockerfile .\"\n        ),\n        shell=True,\n        capture_output=True,\n        text=True,\n    )\n    if result.returncode == 0:\n        self.logger.info(f\"\u2705 Built Docker image {self.image_name}\")\n    else:\n        self.logger.error(f\"\u274c Failed to build Docker image: {result.stderr}\\n{result.stdout}{result.stderr}\")\n        raise RuntimeError(f\"Failed to build Docker image: {result.stderr}\")\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.copy_logs_from_env","title":"copy_logs_from_env","text":"<pre><code>copy_logs_from_env(round_num: int) -&gt; None\n</code></pre> <p>Copy logs from the game's environment to the local machine.</p> Source code in <code>codeclash/games/game.py</code> <pre><code>def copy_logs_from_env(self, round_num: int) -&gt; None:\n    \"\"\"Copy logs from the game's environment to the local machine.\"\"\"\n    (self.log_local / \"rounds\" / str(round_num)).mkdir(parents=True, exist_ok=True)\n    copy_from_container(\n        container=self.environment,\n        src_path=str(self.log_env) + \"/.\",\n        dest_path=self.log_round(round_num),\n    )\n\n    # Remove logs from container to save space\n    assert_zero_exit_code(\n        self.environment.execute(f\"rm -rf {self.log_env}\"),\n        logger=self.logger,\n    )\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.end","title":"end","text":"<pre><code>end(cleanup: bool = False)\n</code></pre> Source code in <code>codeclash/games/game.py</code> <pre><code>def end(self, cleanup: bool = False):\n    if cleanup:\n        for artifact in self.artifacts:\n            if artifact.exists():\n                subprocess.run(f\"rm -rf {artifact}\", shell=True)\n        self.logger.info(f\"\ud83e\uddfc Cleaned up {self.name} game\")\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.log_round","title":"log_round","text":"<pre><code>log_round(round_num: int) -&gt; Path\n</code></pre> Source code in <code>codeclash/games/game.py</code> <pre><code>def log_round(self, round_num: int) -&gt; Path:\n    return self.log_local / \"rounds\" / str(round_num)\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.get_environment","title":"get_environment","text":"<pre><code>get_environment(branch_name: str | None = None) -&gt; DockerEnvironment\n</code></pre> <p>Get docker container ID with the game code installed.</p> Source code in <code>codeclash/games/game.py</code> <pre><code>def get_environment(self, branch_name: str | None = None) -&gt; DockerEnvironment:\n    \"\"\"Get docker container ID with the game code installed.\"\"\"\n    self.build_image()\n    if not self._keep_containers:\n        run_args = [\"--rm\"]\n    else:\n        run_args = []\n    environment = DockerEnvironment(\n        image=self.image_name,\n        cwd=str(DIR_WORK),\n        env={\n            \"GITHUB_TOKEN\": os.getenv(\"GITHUB_TOKEN\", \"\"),\n            \"PAGER\": \"cat\",\n            \"MANPAGER\": \"cat\",\n            \"LESS\": \"-R\",\n            \"PIP_PROGRESS_BAR\": \"off\",\n            \"TQDM_DISABLE\": \"1\",\n        },\n        container_timeout=\"10h\",\n        logger=self.logger,\n        run_args=run_args,\n    )\n\n    branch_name = self.game_id if branch_name is None else branch_name\n\n    # Manually set URL with github token and git fetch/pull everything\n    # We won't raise an error if the token is not set or the URL doesn't have the right format.\n    if github_token := os.getenv(\"GITHUB_TOKEN\"):\n        result = assert_zero_exit_code(environment.execute(\"git remote get-url origin\"))\n        current_url = result[\"output\"].strip()\n        if current_url.startswith(\"https://\") and \"@\" not in current_url:\n            new_url = current_url.replace(\"https://\", f\"https://{github_token}@\")\n            assert_zero_exit_code(\n                environment.execute(f\"git remote set-url origin {new_url} &amp;&amp; git fetch --all &amp;&amp; git pull\")\n            )\n        else:\n            self.logger.warning(\"Remote origin URL is not https://, won't be able to set token and pull.\")\n    else:\n        self.logger.warning(\"GITHUB_TOKEN environment variable is not set, won't be able to pull.\")\n\n    # Logger setting will likely not take effect for initial container creation logs\n    environment.logger = get_logger(\"environment\", emoji=\"\ud83e\udeb4\")\n    for cmd in [\n        f\"git branch {branch_name}\",\n        f\"git checkout {branch_name}\",\n        'git config --global user.email \"player@codeclash.com\"',\n        'git config --global user.name \"Player\"',\n        \"git config --global commit.gpgsign false\",\n    ]:\n        assert_zero_exit_code(environment.execute(cmd), logger=self.logger)\n    return environment\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata() -&gt; dict\n</code></pre> <p>This is what we write to metadata.json. You can subclass extend this to add more details for specific games.</p> Source code in <code>codeclash/games/game.py</code> <pre><code>def get_metadata(self) -&gt; dict:\n    \"\"\"This is what we write to metadata.json.\n    You can subclass extend this to add more details for specific games.\n    \"\"\"\n    return self._metadata\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.run_round","title":"run_round","text":"<pre><code>run_round(agents: list[Player], round_num: int, *, copy_logs: bool = True) -&gt; RoundStats\n</code></pre> <p>Run a single round of the game with the given agents.</p> <p>Returns the log output, result output, and winner name. All bookkeeping should be handled by the tournament class.</p> Source code in <code>codeclash/games/game.py</code> <pre><code>def run_round(self, agents: list[Player], round_num: int, *, copy_logs: bool = True) -&gt; RoundStats:\n    \"\"\"\n    Run a single round of the game with the given agents.\n\n    Returns the log output, result output, and winner name. All bookkeeping should be\n    handled by the tournament class.\n    \"\"\"\n    all_names = {agent.name for agent in agents}\n    assert len(all_names) == len(agents), \"All agents must have unique names\"\n\n    random.shuffle(agents)  # Shuffle to ensure fairness in case of positional advantages\n    stats = RoundStats(round_num, agents)\n    validated: list[Player] = []\n    for a in agents:\n        is_valid, error = self.validate_code(a)\n        if not is_valid:\n            self.logger.warning(f\"Agent {a.name} failed submission validation: {error}\")\n            stats.player_stats[a.name].invalid_reason = error\n            continue\n        self.logger.info(f\"Agent {a.name} passed submission validation\")\n        stats.player_stats[a.name].valid_submit = True\n        validated.append(a)\n\n    sims = self.config[\"game\"][\"sims_per_round\"]\n    if len(validated) &gt; 1:\n        self._pre_round_setup(validated)\n        self.execute_round(validated)\n        if copy_logs:\n            self.copy_logs_from_env(round_num)\n        self.get_results(validated, round_num, stats)\n    elif len(validated) == 1:\n        self.logger.info(f\"Only one valid agent ({validated[0].name}), automatic win\")\n        stats.winner = validated[0].name\n        stats.scores[validated[0].name] = sims\n        stats.player_stats[validated[0].name].score = sims\n    else:\n        self.logger.info(\"No valid agents, no winner this round (Default tie)\")\n        stats.winner = RESULT_TIE\n        # Split points evenly\n        points = sims * 1.0 / len(agents)\n        for a in agents:\n            stats.scores[a.name] = points\n            stats.player_stats[a.name].score = points\n    return stats\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.get_results","title":"get_results  <code>abstractmethod</code>","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> <p>Determine the winner of the game based on the result output. Modifies the stats object in place.</p> <p>Parameters:</p> Name Type Description Default <code>agents</code> <code>list[Player]</code> <p>List of agents participating in the round</p> required Source code in <code>codeclash/games/game.py</code> <pre><code>@abstractmethod\ndef get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    \"\"\"Determine the winner of the game based on the result output.\n    Modifies the stats object in place.\n\n    Args:\n        agents: List of agents participating in the round\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.execute_round","title":"execute_round  <code>abstractmethod</code>","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> <p>Subclasses implement their game-specific logic here. This is the low level implementation, you probably want to use run_round instead, which includes the pre-round setup, post-round setup, and winner determination.</p> Source code in <code>codeclash/games/game.py</code> <pre><code>@abstractmethod\ndef execute_round(self, agents: list[Player]):\n    \"\"\"Subclasses implement their game-specific logic here.\n    This is the low level implementation, you probably want to use run_round instead, which\n    includes the pre-round setup, post-round setup, and winner determination.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.CodeGame.validate_code","title":"validate_code  <code>abstractmethod</code>","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> <p>Verify that the given agent can be run by the game.</p> <p>Parameters:</p> Name Type Description Default <code>agent</code> <code>Player</code> <p>The agent to verify</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Boolean indicating whether the agent passed verification</p> <code>str | None</code> <p>Optional string indicating reason for failure</p> Source code in <code>codeclash/games/game.py</code> <pre><code>@abstractmethod\ndef validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    \"\"\"Verify that the given agent can be run by the game.\n\n    Args:\n        agent: The agent to verify\n\n    Returns:\n        Boolean indicating whether the agent passed verification\n        Optional string indicating reason for failure\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/arenas/game/#supporting-classes","title":"Supporting Classes","text":""},{"location":"reference/arenas/game/#playerstats","title":"PlayerStats","text":""},{"location":"reference/arenas/game/#codeclash.games.game.PlayerStats","title":"codeclash.games.game.PlayerStats","text":"<pre><code>PlayerStats(name: str)\n</code></pre> Source code in <code>codeclash/games/game.py</code> <pre><code>def __init__(self, name: str):\n    self.name = name\n    self.invalid_reason: str = \"\"\n    self.score: float = 0.0\n    self.valid_submit = False\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.PlayerStats.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.PlayerStats.invalid_reason","title":"invalid_reason  <code>instance-attribute</code>","text":"<pre><code>invalid_reason: str = ''\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.PlayerStats.score","title":"score  <code>instance-attribute</code>","text":"<pre><code>score: float = 0.0\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.PlayerStats.valid_submit","title":"valid_submit  <code>instance-attribute</code>","text":"<pre><code>valid_submit = False\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.PlayerStats.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>codeclash/games/game.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return {\n        \"name\": self.name,\n        \"invalid_reason\": self.invalid_reason,\n        \"score\": self.score,\n        \"valid_submit\": self.valid_submit,\n    }\n</code></pre>"},{"location":"reference/arenas/game/#roundstats","title":"RoundStats","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/game/#codeclash.games.game.RoundStats","title":"codeclash.games.game.RoundStats","text":"<pre><code>RoundStats(round_num: int, agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/game.py</code> <pre><code>def __init__(self, round_num: int, agents: list[Player]):\n    self.winner = None\n    self.round_num = round_num\n    # Map of player to game metric (e.g. # of wins, assets accumulated)\n    self.scores: dict[str, float] = {a.name: 0.0 for a in agents}\n    self.player_stats: dict[str, PlayerStats] = {agent.name: PlayerStats(name=agent.name) for agent in agents}\n    self.details: list[str] = []\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.RoundStats.winner","title":"winner  <code>instance-attribute</code>","text":"<pre><code>winner = None\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.RoundStats.round_num","title":"round_num  <code>instance-attribute</code>","text":"<pre><code>round_num = round_num\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.RoundStats.scores","title":"scores  <code>instance-attribute</code>","text":"<pre><code>scores: dict[str, float] = {(name): 0.0for a in agents}\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.RoundStats.player_stats","title":"player_stats  <code>instance-attribute</code>","text":"<pre><code>player_stats: dict[str, PlayerStats] = {(name): (PlayerStats(name=name))for agent in agents}\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.RoundStats.details","title":"details  <code>instance-attribute</code>","text":"<pre><code>details: list[str] = []\n</code></pre>"},{"location":"reference/arenas/game/#codeclash.games.game.RoundStats.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> Source code in <code>codeclash/games/game.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    # Going through some pain to ensure that the scores dict is always complete\n    player_names = set(self.player_stats.keys()) | set(self.scores.keys())\n    return {\n        \"round_num\": self.round_num,\n        \"winner\": self.winner,\n        \"details\": self.details,\n        \"scores\": {name: self.scores.get(name, 0.0) for name in player_names},\n        \"player_stats\": {name: stats.to_dict() for name, stats in self.player_stats.items()},\n    }\n</code></pre>"},{"location":"reference/arenas/halite/","title":"Halite","text":"<p>Resource collection and strategy game where bots compete to mine halite from a grid.</p>"},{"location":"reference/arenas/halite/#overview","title":"Overview","text":"<p>Halite is a resource management game where players write bots to collect halite (resources) more efficiently than opponents.</p>"},{"location":"reference/arenas/halite/#game-rules","title":"Game Rules","text":"<ul> <li>Bots move on a grid collecting halite</li> <li>Depositing halite at dropoff points scores points</li> <li>Ships can collide and destroy each other</li> <li>Most halite collected wins</li> </ul>"},{"location":"reference/arenas/halite/#configuration-example","title":"Configuration Example","text":"<pre><code>game:\n  name: Halite\n  rounds: 10\n  sims_per_round: 3\n  timeout: 400\n\nplayers:\n  - name: Miner1\n    model: gpt-4\n  - name: Miner2\n    model: claude-3\n</code></pre>"},{"location":"reference/arenas/halite/#resources","title":"Resources","text":"<ul> <li>Halite Documentation</li> <li>Game Specifications</li> </ul>"},{"location":"reference/arenas/halite/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame","title":"codeclash.games.halite.halite.HaliteGame","text":"<pre><code>HaliteGame(config, **kwargs)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/halite/halite.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    self.run_cmd_round: str = f\"./environment/halite --replaydirectory {self.log_env}\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" --{arg}\"\n        else:\n            self.run_cmd_round += f\" --{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'Halite'\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = 'Halite is a multi-player turn-based strategy game where bots compete on a rectangular grid to capture territory and accumulate strength.\\nPlayers control pieces that can move across the map to conquer neutral and enemy territory, with each cell providing production that increases the strength of pieces occupying it.\\nThe goal is to control the most territory by the end of the game through strategic expansion, consolidation of forces, and tactical combat decisions.\\n\\nYou have the choice of writing your Halite bot in one of four programming languages: C, C++, OCaml, or Rust.\\nExample implementations can be found under the `airesources/` folder.\\nYour submission should be stored in the `submission/` folder. This folder currently contains an example C bot, but feel free to use any of the supported languages.\\nPlease make sure your main file is named `main.&lt;ext&gt;`, where `&lt;ext&gt;` is the appropriate file extension for your chosen programming language.\\nYou may include additional files as needed, but please ensure:\\n1. The `submission/` folder contains only files relevant to your bot.\\n2. The `submission/` folder ONLY contains a single bot (no multiple bots in one submission).\\n3. Your bot can be compiled. See `runGame.sh` under the corresponding `submission/&lt;language&gt;/` folder to see how we will compile and run your bot.\\n'\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {}\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'submission'\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.run_cmd_round","title":"run_cmd_round  <code>instance-attribute</code>","text":"<pre><code>run_cmd_round: str = f'./environment/halite --replaydirectory {log_env}'\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/halite/halite.py</code> <pre><code>def execute_round(self, agents: list[Player]):\n    entries = []\n    for agent in agents:\n        executable = agent.environment.execute(f\"cat {HALITE_HIDDEN_EXEC}\")[\"output\"].strip()\n        entries.append(executable)\n    cmd = f\"{self.run_cmd_round} {shlex.join(entries)}\"\n    self.logger.info(f\"Running game: {cmd}\")\n    with ThreadPoolExecutor(20) as executor:\n        futures = [\n            executor.submit(self._run_single_simulation, agents, idx, cmd)\n            for idx in range(self.game_config[\"sims_per_round\"])\n        ]\n        for future in tqdm(as_completed(futures), total=len(futures)):\n            future.result()\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/halite/halite.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    winners = []\n    pattern = r\"Player\\s#(\\d+),\\s(.*),\\scame\\sin\\srank\\s#(\\d+)\"\n    for idx in range(self.game_config[\"sims_per_round\"]):\n        log_file = self.log_round(round_num) / HALITE_LOG.format(idx=idx)\n        with open(log_file) as f:\n            lines = f.readlines()[-len(agents) - 1 :]\n            for line in lines:\n                match = re.search(pattern, line)\n                if match:\n                    player_idx = int(match.group(1)) - 1\n                    rank = int(match.group(3))\n                    if rank == 1:\n                        winners.append(agents[player_idx].name)\n\n    # Count wins\n    win_counts = Counter(winners)\n\n    # Find all winners with the maximum count\n    max_wins = max(win_counts.values(), default=0)\n    overall_winners = [name for name, count in win_counts.items() if count == max_wins]\n\n    # Update stats\n    stats.winner = RESULT_TIE if len(overall_winners) &gt; 1 else overall_winners[0]\n    stats.scores = dict(win_counts)\n    for player, score in win_counts.items():\n        if player != RESULT_TIE:\n            stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/halite/#codeclash.games.halite.halite.HaliteGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/halite/halite.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    # Check that the `submission/` folder exists\n    exists_output = agent.environment.execute(\"test -d submission &amp;&amp; echo 'exists'\")[\"output\"]\n    if \"exists\" != exists_output.strip():\n        return False, f\"Submission folder `{self.submission}/` does not exist\"\n\n    # Check that there is a *single* file called \"main.&lt;ext&gt;\" in the submission folder\n    # and that &lt;ext&gt; is one of the supported file types\n    sub_path = Path(agent.environment.config.cwd) / self.submission\n    ls_output = agent.environment.execute(\"ls\", cwd=sub_path)[\"output\"]\n    main_files = [\n        fname\n        for fname in ls_output.splitlines()\n        if fname.startswith(\"main.\") and Path(fname).suffix in MAP_FILE_TYPE_TO_RUN\n    ]\n    supported_exts = \"|\".join(MAP_FILE_TYPE_TO_RUN.keys())\n    if len(main_files) != 1:\n        return (\n            False,\n            f\"Exactly one main.[{supported_exts}] file must be present in submission, found {len(main_files)}\",\n        )\n    main_ext = Path(main_files[0]).suffix\n\n    # Check that the submission compiles if necessary\n    if main_ext in MAP_FILE_TYPE_TO_COMPILE:\n        compile_cmd = MAP_FILE_TYPE_TO_COMPILE[main_ext].format(path=\"main\", name=\"main\")\n        try:\n            compile_response = agent.environment.execute(compile_cmd, timeout=15, cwd=sub_path)\n        except subprocess.TimeoutExpired:\n            return False, f\"Compilation failed (ran {compile_cmd} inside {self.submission}): timed out\"\n        if compile_response[\"returncode\"] != 0:\n            return (\n                False,\n                f\"Compilation failed (ran {compile_cmd} inside {self.submission}): {compile_response['output']}\",\n            )\n\n    # Check that submission runs in competition\n    executable = MAP_FILE_TYPE_TO_RUN[main_ext].format(path=self.submission, name=\"main\")\n    run_cmd = f\"./environment/halite {shlex.join([executable, executable])}\"\n    try:\n        run_response = agent.environment.execute(run_cmd, timeout=15)\n    except subprocess.TimeoutExpired:\n        return False, f\"Submission failed to run (ran {run_cmd}): timed out\"\n    if run_response[\"returncode\"] != 0:\n        return False, f\"Submission failed to run (ran {run_cmd}): {run_response['output']}\"\n\n    # Record command to run executable to hidden file\n    executable_comp = MAP_FILE_TYPE_TO_RUN[main_ext].format(path=f\"/{agent.name}/{self.submission}\", name=\"main\")\n    agent.environment.execute(f'echo \"{executable_comp}\" &gt; {HALITE_HIDDEN_EXEC}')\n    return True, None\n</code></pre>"},{"location":"reference/arenas/halite2/","title":"Halite II","text":"<p>Second version of Halite with planetary conquest mechanics.</p>"},{"location":"reference/arenas/halite2/#overview","title":"Overview","text":"<p>Halite II introduces planetary docking, combat, and more complex strategies.</p>"},{"location":"reference/arenas/halite2/#resources","title":"Resources","text":"<ul> <li>Halite II Documentation</li> </ul>"},{"location":"reference/arenas/halite2/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/halite2/#codeclash.games.halite2.halite2.Halite2Game","title":"codeclash.games.halite2.halite2.Halite2Game","text":"<pre><code>Halite2Game(config, **kwargs)\n</code></pre> <p>               Bases: <code>HaliteGame</code></p> Source code in <code>codeclash/games/halite/halite.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    self.run_cmd_round: str = f\"./environment/halite --replaydirectory {self.log_env}\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" --{arg}\"\n        else:\n            self.run_cmd_round += f\" --{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/halite2/#codeclash.games.halite2.halite2.Halite2Game.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'Halite-II'\n</code></pre>"},{"location":"reference/arenas/halite2/#codeclash.games.halite2.halite2.Halite2Game.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"reference/arenas/halite2/#codeclash.games.halite2.halite2.Halite2Game.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {}\n</code></pre>"},{"location":"reference/arenas/halite2/#codeclash.games.halite2.halite2.Halite2Game.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'submission'\n</code></pre>"},{"location":"reference/arenas/halite3/","title":"Halite III","text":"<p>Third version of Halite with inspirations from the original.</p>"},{"location":"reference/arenas/halite3/#overview","title":"Overview","text":"<p>Halite III returns to the resource collection mechanics with new twists.</p>"},{"location":"reference/arenas/halite3/#resources","title":"Resources","text":"<ul> <li>Halite III Documentation</li> </ul>"},{"location":"reference/arenas/halite3/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/halite3/#codeclash.games.halite3.halite3.Halite3Game","title":"codeclash.games.halite3.halite3.Halite3Game","text":"<pre><code>Halite3Game(config, **kwargs)\n</code></pre> <p>               Bases: <code>HaliteGame</code></p> Source code in <code>codeclash/games/halite/halite.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    self.run_cmd_round: str = f\"./environment/halite --replaydirectory {self.log_env}\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" --{arg}\"\n        else:\n            self.run_cmd_round += f\" --{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/halite3/#codeclash.games.halite3.halite3.Halite3Game.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'Halite-III'\n</code></pre>"},{"location":"reference/arenas/halite3/#codeclash.games.halite3.halite3.Halite3Game.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = ''\n</code></pre>"},{"location":"reference/arenas/halite3/#codeclash.games.halite3.halite3.Halite3Game.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {}\n</code></pre>"},{"location":"reference/arenas/halite3/#codeclash.games.halite3.halite3.Halite3Game.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'submission'\n</code></pre>"},{"location":"reference/arenas/huskybench/","title":"HuskyBench","text":""},{"location":"reference/arenas/huskybench/#overview","title":"Overview","text":"<p>Huskybench is an implementation of Husky Hold'em</p>"},{"location":"reference/arenas/huskybench/#resources","title":"Resources","text":"<ul> <li>Huskybench</li> </ul>"},{"location":"reference/arenas/huskybench/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame","title":"codeclash.games.huskybench.huskybench.HuskyBenchGame","text":"<pre><code>HuskyBenchGame(config, **kwargs)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/huskybench/huskybench.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    self.num_players: int = len(config[\"players\"])\n    self.run_engine: str = (\n        f\"python engine/main.py --port {HB_PORT} --players {self.num_players} \"\n        f\"--sim --sim-rounds {self.game_config['sims_per_round']}\"\n    )\n    # Game timeout is number of sims * bot timeout\n    self.timeout = self.game_config[\"sims_per_round\"] * HB_BOT_TIMEOUT\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_engine += f\" --{arg}\"\n        else:\n            self.run_engine += f\" --{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'HuskyBench'\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = f'In this game, you will write code to control a poker-playing bot, aiming to outsmart your opponents and win chips.\nVictory comes from crafting clever strategies\u2014bluffing, reading opponents, and managing your chip stack effectively.\nBe mindful of your bot's efficiency - your code should complete a simulation within 10 seconds to avoid forfeiting the round.\nYou can use {HB_SCRIPT} to check if your bot runs in time.'\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'client/player.py'\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.num_players","title":"num_players  <code>instance-attribute</code>","text":"<pre><code>num_players: int = len(config['players'])\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.run_engine","title":"run_engine  <code>instance-attribute</code>","text":"<pre><code>run_engine: str = f'python engine/main.py --port {HB_PORT} --players {num_players} --sim --sim-rounds {game_config['sims_per_round']}'\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.timeout","title":"timeout  <code>instance-attribute</code>","text":"<pre><code>timeout = game_config['sims_per_round'] * HB_BOT_TIMEOUT\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/huskybench/huskybench.py</code> <pre><code>def execute_round(self, agents: list[Player]):\n    # Use placeholders compatible with str.format; compute log dir separately\n    run_client = \"cd /{agent.name} &amp;&amp; python client/main.py --port {port} &gt; {log_dir}/{agent.name}.log 2&gt;&amp;1 &amp;\"\n    run_engine = f\"{self.run_engine} &gt; {self.log_env / HB_LOG_ENGINE} 2&gt;&amp;1 &amp;\"\n    script = self._construct_game_script(agents, run_client, run_engine, verbose=True, log_outputs=True)\n    self.logger.info(f\"Executing game script:\\n{script}\")\n    create_file_in_container(container=self.environment, content=script, dest_path=DIR_WORK / HB_SCRIPT)\n    self.logger.info(f\"Running game script: ./{HB_SCRIPT}\")\n    self.environment.execute(f\"chmod +x {HB_SCRIPT}; ./{HB_SCRIPT}\", timeout=self.timeout)\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/huskybench/huskybench.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    map_id_to_agent = {}\n    for agent in agents:\n        with open(self.log_round(round_num) / f\"{agent.name}.log\") as f:\n            for line in f:\n                if \"Connected with player ID: \" in line:\n                    agent_id = line.strip().split()[-1]\n                    map_id_to_agent[agent_id] = agent.name\n                    break\n    self.logger.info(\"Agent IDs: \" + str(map_id_to_agent))\n\n    with open(self.log_round(round_num) / HB_LOG_ENGINE) as f:\n        score_updates = [\n            (match.group(1), int(match.group(2))) for l in f.readlines() if (match := HB_REGEX_SCORE.search(l))\n        ]\n        map_id_to_score = {k: v for k, v in score_updates[-self.num_players :]}\n    self.logger.info(\"Final Scores: \" + str(map_id_to_score))\n    scores = {map_id_to_agent[agent_id]: score for agent_id, score in map_id_to_score.items()}\n\n    stats.winner = max(scores, key=scores.get)\n    stats.scores = scores\n    for player, score in scores.items():\n        stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/huskybench/#codeclash.games.huskybench.huskybench.HuskyBenchGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/huskybench/huskybench.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    assets = agent.environment.execute(\"ls client\")[\"output\"]\n    if \"main.py\" not in assets:\n        return False, \"There should be a `client/main.py` file\"\n    if \"player.py\" not in assets:\n        return False, \"There should be a `client/player.py` file\"\n\n    # Make sure bot can run (check against itself)\n    run_engine = (\n        self.run_engine.replace(f\"--sim-rounds {self.game_config['sims_per_round']}\", \"--sim-rounds 1\") + \" &amp;\"\n    )\n    run_client = \"python client/main.py --port {port} &amp;\"\n    script = self._construct_game_script([agent, agent], run_client, run_engine, verbose=False)\n    self.logger.info(f\"Validating agent {agent.name} with script:\\n{script}\")\n    create_file_in_container(container=agent.environment, content=script, dest_path=DIR_WORK / HB_SCRIPT)\n    try:\n        agent.environment.execute(f\"chmod +x {HB_SCRIPT}; ./{HB_SCRIPT}\", timeout=HB_BOT_TIMEOUT)\n    except subprocess.TimeoutExpired:\n        return (\n            False,\n            f\"Your submission did not successfully complete a single round of poker within \"\n            f\"the {HB_BOT_TIMEOUT} second time limit.\\n\\n\"\n            \"Please reduce your bot's computation time. \"\n            \"It might also be possible that your code has compilation errors.\\n\\n\"\n            f\"Validation command run: `./{HB_SCRIPT}`\",\n        )\n    return True, None\n</code></pre>"},{"location":"reference/arenas/robocode/","title":"RoboCode","text":"<p>Java-based robot programming game where robots battle in an arena.</p>"},{"location":"reference/arenas/robocode/#overview","title":"Overview","text":"<p>RoboCode is a programming game where players develop tanks in Java to battle each other in a graphical arena.</p>"},{"location":"reference/arenas/robocode/#game-rules","title":"Game Rules","text":"<ul> <li>Robots are programmed in Java</li> <li>Battle in 2D arena</li> <li>Scan for enemies, move, and fire</li> <li>Destroy opponents to win</li> </ul>"},{"location":"reference/arenas/robocode/#configuration-example","title":"Configuration Example","text":"<pre><code>game:\n  name: RoboCode\n  rounds: 10\n  sims_per_round: 5\n  timeout: 300\n\nplayers:\n  - name: Tank1\n    model: gpt-4\n  - name: Tank2\n    model: claude-3\n</code></pre>"},{"location":"reference/arenas/robocode/#resources","title":"Resources","text":"<ul> <li>RoboCode Official Site</li> <li>RoboCode API</li> </ul>"},{"location":"reference/arenas/robocode/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame","title":"codeclash.games.robocode.robocode.RoboCodeGame","text":"<pre><code>RoboCodeGame(config, **kwargs)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/robocode/robocode.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    self.run_cmd_round: str = \"./robocode.sh\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" -{arg}\"\n        else:\n            self.run_cmd_round += f\" -{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'RoboCode'\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = f'Robocode (Tank Royale) is a programming game where your code is the tank: each turn your bot sends intents\u2014speed plus body/gun/radar turn rates and firepower\u2014based on the game state it perceives via radar.\nYour program decides how to move, aim, and fire in a deterministic, turn-based arena to outlast other bots.\nYour bot logic must be written in Java and located in the `robots/custom/` directory.\nKeep the main bot class named `{str(RC_FILE)}`, but you can include additional Java files if you'd like.'\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {'nodisplay': True, 'nosound': True}\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'robots/custom/'\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.run_cmd_round","title":"run_cmd_round  <code>instance-attribute</code>","text":"<pre><code>run_cmd_round: str = './robocode.sh'\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/robocode/robocode.py</code> <pre><code>    def execute_round(self, agents: list[Player]):\n        for agent in agents:\n            # Copy the agent codebase into the game codebase and compile it\n            for cmd in [\n                f\"mkdir -p robots/{agent.name}\",\n                f\"cp -r /{agent.name}/robots/custom/* robots/{agent.name}/\",\n                f\"find robots/{agent.name}/ -name '*.java' -exec sed -i 's/custom/{agent.name}/g' {{}} +\",\n                f'javac -cp \"libs/robocode.jar\" robots/{agent.name}/*.java',\n            ]:\n                self.environment.execute(cmd)\n\n        # Create .battle file\n        selected_robots = \",\".join([f\"{agent.name}.{RC_FILE.stem}*\" for agent in agents])\n        # Use timestamp for unique battle file name since rounds are managed by tournament\n        battle_file = f\"{self.game_id}-battle{int(time.time())}.battle\"\n        battle_content = f\"\"\"#Battle Properties\n{self._get_battle_config()}\nrobocode.battle.selectedRobots={selected_robots}\n\"\"\"\n        create_file_in_container(self.environment, content=battle_content, dest_path=f\"battles/{battle_file}\")\n\n        # Run battle with results output to file\n        cmd = f\"{self.run_cmd_round} -battle {battle_file}\"\n        self.logger.info(f\"Running game: {cmd}\")\n        with ThreadPoolExecutor(5) as executor:\n            # Submit all simulations to the thread pool\n            futures = [\n                executor.submit(self._run_single_simulation, agents, idx, cmd)\n                for idx in range(self.game_config.get(\"sims_per_round\", 100) // SIMS_PER_RUN)\n            ]\n\n            # Collect results as they complete\n            for future in tqdm(as_completed(futures), total=len(futures)):\n                future.result()\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/robocode/robocode.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    scores = defaultdict(int)\n    for idx in range(self.game_config.get(\"sims_per_round\", 100) // SIMS_PER_RUN):\n        with open(self.log_round(round_num) / f\"results_{idx}.txt\") as f:\n            result_output = f.read()\n        lines = result_output.strip().split(\"\\n\")\n\n        for line in lines:\n            line = line.strip()\n            if not re.match(r\"^\\d\", line):\n                continue\n            match = re.search(r\"(\\d+)\\S+\\:\\s(\\S+)\\s+(\\d+)\", line)\n            if match:\n                player = match.group(2).rsplit(\".\", 1)[0]\n                scores[player] += int(match.group(3))\n\n    stats.winner = max(scores, key=scores.get)\n    stats.scores = scores\n    for player, score in scores.items():\n        stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/robocode/#codeclash.games.robocode.robocode.RoboCodeGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/robocode/robocode.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    if \"robots\" not in agent.environment.execute(\"ls\")[\"output\"]:\n        return False, \"There should be a `robots/` directory\"\n    if \"custom\" not in agent.environment.execute(\"ls robots\")[\"output\"]:\n        return False, \"There should be a `robots/custom/` directory\"\n    if str(RC_FILE) not in agent.environment.execute(\"ls robots/custom\")[\"output\"]:\n        return False, (\n            f\"There should be a `robots/custom/{RC_FILE}` file. \"\n            f\"You can include additional files, but the primary tank logic must be in `robots/custom/{RC_FILE}`\"\n        )\n    response = agent.environment.execute('javac -cp \"libs/robocode.jar\" robots/custom/*.java')\n    if response[\"returncode\"] != 0:\n        return False, f\"Compilation error:\\n{response['output']}\"\n    if f\"{RC_FILE.stem}.class\" not in agent.environment.execute(\"ls robots/custom\")[\"output\"]:\n        return False, f\"`{RC_FILE.stem}.class` not found after compilation\"\n    return True, None\n</code></pre>"},{"location":"reference/arenas/robotrumble/","title":"RobotRumble","text":"<p>Rust-based robot programming game with modern language features.</p>"},{"location":"reference/arenas/robotrumble/#overview","title":"Overview","text":"<p>RobotRumble is a programming game where players write Rust code to control robots in arena battles.</p>"},{"location":"reference/arenas/robotrumble/#game-rules","title":"Game Rules","text":"<ul> <li>Programs written in Rust</li> <li>Robots battle in 2D grid</li> <li>Move, attack, and coordinate</li> <li>Team with most units wins</li> </ul>"},{"location":"reference/arenas/robotrumble/#configuration-example","title":"Configuration Example","text":"<pre><code>game:\n  name: RobotRumble\n  rounds: 10\n  sims_per_round: 3\n  timeout: 300\n\nplayers:\n  - name: RustBot1\n    model: gpt-4\n  - name: RustBot2\n    model: claude-3\n</code></pre>"},{"location":"reference/arenas/robotrumble/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame","title":"codeclash.games.robotrumble.robotrumble.RobotRumbleGame","text":"<pre><code>RobotRumbleGame(config, **kwargs)\n</code></pre> <p>               Bases: <code>CodeGame</code></p> Source code in <code>codeclash/games/robotrumble/robotrumble.py</code> <pre><code>def __init__(self, config, **kwargs):\n    super().__init__(config, **kwargs)\n    assert len(config[\"players\"]) == 2, \"RobotRumble is a two-player game\"\n    self.run_cmd_round: str = \"./rumblebot run term\"\n    self.sim_ext = \"txt\"\n    for arg, val in self.game_config.get(\"args\", self.default_args).items():\n        if isinstance(val, bool):\n            if val:\n                self.run_cmd_round += f\" --{arg}\"\n                if arg == \"raw\":\n                    self.sim_ext = \"json\"\n        else:\n            self.run_cmd_round += f\" --{arg} {val}\"\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = 'RobotRumble'\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = 'RobotRumble is a turn-based coding battle where you program a team of robots in Python or JavaScript to move, attack, and outmaneuver your opponent on a grid.\\nEvery decision is driven by your code, and victory comes from crafting logic that positions robots smartly, times attacks well, and adapts over the 100-turn match.\\nNOTE: Please ensure that your code runs efficiently (under 60 seconds). Code that exceeds this run time will automatically forfeit the round.'\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.default_args","title":"default_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_args: dict = {'raw': True}\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.submission","title":"submission  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>submission: str = 'robot.js'\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.run_cmd_round","title":"run_cmd_round  <code>instance-attribute</code>","text":"<pre><code>run_cmd_round: str = './rumblebot run term'\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.sim_ext","title":"sim_ext  <code>instance-attribute</code>","text":"<pre><code>sim_ext = 'txt'\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.execute_round","title":"execute_round","text":"<pre><code>execute_round(agents: list[Player])\n</code></pre> Source code in <code>codeclash/games/robotrumble/robotrumble.py</code> <pre><code>def execute_round(self, agents: list[Player]):\n    self.logger.info(f\"Running game with players: {[agent.name for agent in agents]}\")\n    args = []\n    for agent in agents:\n        executable = agent.environment.execute(f\"cat {ROBOTRUMBLE_HIDDEN_EXEC}\")[\"output\"].strip()\n        args.append(f\"/{agent.name}/{executable}\")\n    cmd = f\"{self.run_cmd_round} {shlex.join(args)}\"\n    self.logger.info(f\"Running game: {cmd}\")\n\n    with ThreadPoolExecutor(8) as executor:\n        # Submit all simulations to the thread pool\n        futures = [\n            executor.submit(self._run_single_simulation, agents, idx, cmd)\n            for idx in range(self.game_config.get(\"sims_per_round\", 100))\n        ]\n\n        # Collect results as they complete\n        i_completed = 0\n        for future in as_completed(futures):\n            future.result()\n            i_completed += 1\n            self.logger.info(f\"Completed {i_completed} of {len(futures)} simulations\")\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.get_results","title":"get_results","text":"<pre><code>get_results(agents: list[Player], round_num: int, stats: RoundStats)\n</code></pre> Source code in <code>codeclash/games/robotrumble/robotrumble.py</code> <pre><code>def get_results(self, agents: list[Player], round_num: int, stats: RoundStats):\n    winners = []\n    for idx in range(self.game_config.get(\"sims_per_round\", 100)):\n        output_file = self.log_round(round_num) / f\"sim_{idx}.{self.sim_ext}\"\n        if not output_file.exists():\n            self.logger.warning(f\"Simulation {idx} not found, skipping\")\n            continue\n        winners.append(\n            self._get_winner_txt(output_file, agents)\n            if self.sim_ext == \"txt\"\n            else self._get_winner_json(output_file, agents)\n        )\n\n    # Count wins\n    win_counts = Counter(winners)\n\n    # Find all winners with the maximum count\n    max_wins = max(win_counts.values())\n    overall_winners = [name for name, count in win_counts.items() if count == max_wins]\n\n    # Update stats\n    stats.winner = RESULT_TIE if len(overall_winners) &gt; 1 else overall_winners[0]\n    stats.details.append(f\"In this round, {agents[0].name} was Blue and {agents[1].name} was Red.\")\n    stats.scores = dict(win_counts)\n    for player, score in win_counts.items():\n        if player != RESULT_TIE:\n            stats.player_stats[player].score = score\n</code></pre>"},{"location":"reference/arenas/robotrumble/#codeclash.games.robotrumble.robotrumble.RobotRumbleGame.validate_code","title":"validate_code","text":"<pre><code>validate_code(agent: Player) -&gt; tuple[bool, str | None]\n</code></pre> Source code in <code>codeclash/games/robotrumble/robotrumble.py</code> <pre><code>def validate_code(self, agent: Player) -&gt; tuple[bool, str | None]:\n    # Determine if robot.js or robot.py exists\n    ext, exists = None, False\n    for possible_ext in MAP_EXT_TO_HEADER.keys():\n        exists_output = agent.environment.execute(f\"test -f robot.{possible_ext} &amp;&amp; echo 'exists'\")[\"output\"]\n        if \"exists\" == exists_output.strip():\n            ext = possible_ext\n            exists = True\n            break\n    if not exists:\n        return False, \"There should be a `robot.js` or `robot.py` file\"\n    agent.environment.execute(f'echo \"robot.{ext}\" &gt; {ROBOTRUMBLE_HIDDEN_EXEC}')\n\n    # Check that the robot function is defined\n    header = MAP_EXT_TO_HEADER[ext]\n    if header not in agent.environment.execute(f\"cat robot.{ext}\")[\"output\"]:\n        return (\n            False,\n            f\"robot.{ext} does not contain the required robot function. It should be defined as '{header}'.\",\n        )\n    test_run_cmd = f\"{self.run_cmd_round} robot.{ext} robot.{ext} -t 1\"\n    try:\n        test_run = agent.environment.execute(test_run_cmd, timeout=10)[\"output\"]\n    except subprocess.TimeoutExpired:\n        return (\n            False,\n            f\"Running robot.{ext} (with `{test_run_cmd}`) timed out (10 seconds). Please ensure your code runs efficiently.\",\n        )\n    if \"Some errors occurred:\" in test_run:\n        return False, f\"Running robot.{ext} (with `{test_run_cmd}`) resulted in errors:\\n{test_run}\"\n    return True, None\n</code></pre>"},{"location":"reference/player/dummy/","title":"DummyAgent","text":"<p>Simple test agent for development and debugging.</p>"},{"location":"reference/player/dummy/#overview","title":"Overview","text":"<p>DummyAgent is a minimal agent implementation used for testing.</p>"},{"location":"reference/player/dummy/#implementation","title":"Implementation","text":""},{"location":"reference/player/dummy/#codeclash.agents.dummy_agent.Dummy","title":"codeclash.agents.dummy_agent.Dummy","text":"<pre><code>Dummy(config: dict, environment: DockerEnvironment, game_context: GameContext, push: bool = False)\n</code></pre> <p>               Bases: <code>Player</code></p> <p>A dummy player that does nothing. Mainly for testing purposes.</p> Source code in <code>codeclash/agents/player.py</code> <pre><code>def __init__(\n    self,\n    config: dict,\n    environment: DockerEnvironment,\n    game_context: GameContext,\n    push: bool = False,\n) -&gt; None:\n    self.config = config\n    self.name = config[\"name\"]\n    self._player_unique_id = str(uuid.uuid4())\n    \"\"\"Unique ID that doesn't clash even across multiple games. Used for git tags.\"\"\"\n    self.environment = environment\n    self.game_context = game_context\n    self.push = push\n    self.logger = get_logger(\n        self.name,\n        log_path=self.game_context.log_local / \"players\" / self.name / \"player.log\",\n        emoji=\"\ud83d\udc64\",\n    )\n    self._metadata = {\n        \"name\": self.name,\n        \"player_unique_id\": self._player_unique_id,\n        \"created_timestamp\": int(time.time()),\n        \"config\": self.config,\n        \"initial_commit_hash\": self._get_commit_hash(),\n        \"branch_name\": self._branch_name,\n        \"round_tags\": {},  # mapping round -&gt; tag\n        \"agent_stats\": {},  # mapping round -&gt; agent stats\n    }\n\n    if branch := config.get(\"branch_init\"):\n        self.logger.info(f\"Checking out branch {branch}\")\n        assert_zero_exit_code(self.environment.execute(f\"git checkout {branch}\"), logger=self.logger)\n\n    if self.push:\n        self.logger.info(\"Will push agent gameplay as branch to remote repository after each round\")\n        token = os.getenv(\"GITHUB_TOKEN\")\n        if not token:\n            raise ValueError(\"GITHUB_TOKEN environment variable is required\")\n        for cmd in [\n            \"git remote remove origin\",\n            f\"git remote add origin https://x-access-token:{token}@github.com/{GH_ORG}/{self.game_context.name}.git\",\n        ]:\n            assert_zero_exit_code(self.environment.execute(cmd), logger=self.logger)\n</code></pre>"},{"location":"reference/player/dummy/#codeclash.agents.dummy_agent.Dummy.run","title":"run","text":"<pre><code>run()\n</code></pre> Source code in <code>codeclash/agents/dummy_agent.py</code> <pre><code>def run(self):\n    pass\n</code></pre>"},{"location":"reference/player/dummy/#usage","title":"Usage","text":"<p>Useful for: - Testing game implementations - Debugging tournament infrastructure - Baseline performance comparison</p>"},{"location":"reference/player/dummy/#configuration","title":"Configuration","text":"<pre><code>players:\n  - name: DummyPlayer\n    type: dummy\n</code></pre> bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/player/minisweagent/","title":"MiniSWEAgent","text":"<p>LLM-powered coding agent using the mini-SWE-agent framework.</p>"},{"location":"reference/player/minisweagent/#resources","title":"Resources","text":"<ul> <li>Mini-swe-agent docs</li> <li>mini-swe-agent github</li> </ul>"},{"location":"reference/player/minisweagent/#configuration","title":"Configuration","text":"<pre><code>players:\n  - name: GPTAgent\n    type: minisweagent\n    model: gpt-4-turbo\n    temperature: 0.7\n    max_tokens: 4000\n\n  - name: ClaudeAgent\n    type: minisweagent\n    model: claude-3-opus-20240229\n    temperature: 0.7\n    max_tokens: 4000\n</code></pre>"},{"location":"reference/player/minisweagent/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/player/minisweagent/#codeclash.agents.minisweagent.MiniSWEAgent","title":"codeclash.agents.minisweagent.MiniSWEAgent","text":"<pre><code>MiniSWEAgent(config: dict, environment: DockerEnvironment, game_context: GameContext, push: bool = False)\n</code></pre> <p>               Bases: <code>Player</code></p> <p>Player with agentic code editing capabilities</p> Source code in <code>codeclash/agents/minisweagent.py</code> <pre><code>def __init__(self, config: dict, environment: DockerEnvironment, game_context: GameContext, push: bool = False):\n    super().__init__(config, environment=environment, game_context=game_context, push=push)\n</code></pre>"},{"location":"reference/player/minisweagent/#codeclash.agents.minisweagent.MiniSWEAgent.run","title":"run","text":"<pre><code>run()\n</code></pre> Source code in <code>codeclash/agents/minisweagent.py</code> <pre><code>def run(self):\n    # temporary workaround around https://github.com/SWE-agent/mini-swe-agent/issues/477\n    if \"DeterministicModel\" not in self.config[\"config\"][\"model\"].get(\"model_class\", \"\"):\n        model = get_model(config=self.config[\"config\"][\"model\"])\n    else:\n        model = DeterministicModel(outputs=self.config[\"config\"][\"model\"][\"outputs\"])\n    self.agent = ClashAgent(\n        model=model,\n        env=self.environment,\n        logger=self.logger,\n        **self.config[\"config\"][\"agent\"],\n    )\n    exit_status = None\n    result = None\n    exc_message = None\n    try:\n        exit_status, result = self.agent.run(task=\"\", **self.game_context.to_template_vars())\n    except Exception as e:\n        exit_status = str(e)\n        exc_message = traceback.format_exc()\n        result = exc_message\n        self.logger.critical(exc_message)\n    finally:\n        traj_path = (\n            self.game_context.log_local\n            / \"players\"\n            / self.name\n            / f\"{self.name}_r{self.game_context.round}.traj.json\"\n        )\n        save_traj(\n            self.agent,  # type: ignore\n            traj_path,\n            exit_status=exit_status,\n            result=result,\n            print_fct=self.logger.debug,\n        )\n        copy_to_container(\n            self.environment,\n            traj_path,\n            self.game_context.log_env / \"edits\" / traj_path.name,\n        )\n        self._metadata[\"agent_stats\"][self.game_context.round] = {\n            \"exit_status\": exit_status,\n            \"cost\": self.agent.model.cost,\n            \"api_calls\": self.agent.model.n_calls,\n        }\n    if exit_status.lower().strip() not in [\"\", \"submitted\", \"limitsexceeded\"] and exc_message is not None:\n        raise RuntimeError(f\"Agent {self.name} failed with exit status: {exit_status} and exception: {exc_message}\")\n</code></pre>"},{"location":"reference/player/player/","title":"Player (Abstract Base)","text":"<p>The <code>Player</code> class is the abstract base class for all agents in CodeClash.</p>"},{"location":"reference/player/player/#overview","title":"Overview","text":"<p>Players are agents that:</p> <ol> <li>Receive game context and logs</li> <li>Analyze the current state</li> <li>Modify their code to improve performance</li> <li>Submit code for validation and execution</li> </ol>"},{"location":"reference/player/player/#key-concepts","title":"Key Concepts","text":""},{"location":"reference/player/player/#player-lifecycle","title":"Player Lifecycle","text":"<ol> <li>Initialization: Player container created with game code</li> <li>Round Loop: For each round:</li> <li><code>pre_run_hook()</code>: Prepare for the round</li> <li><code>run()</code>: Agent modifies code</li> <li><code>post_run_hook()</code>: Commit changes, save diffs</li> <li>Metadata: Collect statistics and git history</li> </ol>"},{"location":"reference/player/player/#docker-environment","title":"Docker Environment","text":"<p>Each player has an isolated Docker container with:</p> <ul> <li>Game repository checked out</li> <li>Git initialized on unique branch</li> <li>Access to game logs</li> </ul>"},{"location":"reference/player/player/#git-integration","title":"Git Integration","text":"<p>Players maintain git history:</p> <ul> <li>Each round creates a commit</li> <li>Git tags mark round checkpoints</li> <li>Diffs track code evolution</li> </ul>"},{"location":"reference/player/player/#class-reference","title":"Class Reference","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/player/player/#codeclash.agents.player.Player","title":"codeclash.agents.player.Player","text":"<pre><code>Player(config: dict, environment: DockerEnvironment, game_context: GameContext, push: bool = False)\n</code></pre> <p>               Bases: <code>ABC</code></p> Source code in <code>codeclash/agents/player.py</code> <pre><code>def __init__(\n    self,\n    config: dict,\n    environment: DockerEnvironment,\n    game_context: GameContext,\n    push: bool = False,\n) -&gt; None:\n    self.config = config\n    self.name = config[\"name\"]\n    self._player_unique_id = str(uuid.uuid4())\n    \"\"\"Unique ID that doesn't clash even across multiple games. Used for git tags.\"\"\"\n    self.environment = environment\n    self.game_context = game_context\n    self.push = push\n    self.logger = get_logger(\n        self.name,\n        log_path=self.game_context.log_local / \"players\" / self.name / \"player.log\",\n        emoji=\"\ud83d\udc64\",\n    )\n    self._metadata = {\n        \"name\": self.name,\n        \"player_unique_id\": self._player_unique_id,\n        \"created_timestamp\": int(time.time()),\n        \"config\": self.config,\n        \"initial_commit_hash\": self._get_commit_hash(),\n        \"branch_name\": self._branch_name,\n        \"round_tags\": {},  # mapping round -&gt; tag\n        \"agent_stats\": {},  # mapping round -&gt; agent stats\n    }\n\n    if branch := config.get(\"branch_init\"):\n        self.logger.info(f\"Checking out branch {branch}\")\n        assert_zero_exit_code(self.environment.execute(f\"git checkout {branch}\"), logger=self.logger)\n\n    if self.push:\n        self.logger.info(\"Will push agent gameplay as branch to remote repository after each round\")\n        token = os.getenv(\"GITHUB_TOKEN\")\n        if not token:\n            raise ValueError(\"GITHUB_TOKEN environment variable is required\")\n        for cmd in [\n            \"git remote remove origin\",\n            f\"git remote add origin https://x-access-token:{token}@github.com/{GH_ORG}/{self.game_context.name}.git\",\n        ]:\n            assert_zero_exit_code(self.environment.execute(cmd), logger=self.logger)\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = config['name']\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.environment","title":"environment  <code>instance-attribute</code>","text":"<pre><code>environment = environment\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.game_context","title":"game_context  <code>instance-attribute</code>","text":"<pre><code>game_context = game_context\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.push","title":"push  <code>instance-attribute</code>","text":"<pre><code>push = push\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger(name, log_path=log_local / 'players' / name / 'player.log', emoji='\ud83d\udc64')\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.pre_run_hook","title":"pre_run_hook","text":"<pre><code>pre_run_hook(*, new_round: int) -&gt; None\n</code></pre> <p>Should be called before we call the run method.</p> Source code in <code>codeclash/agents/player.py</code> <pre><code>def pre_run_hook(self, *, new_round: int) -&gt; None:\n    \"\"\"Should be called before we call the run method.\"\"\"\n    if new_round == 1:\n        self._tag_round(0)\n    self.game_context.round = new_round\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.post_run_hook","title":"post_run_hook","text":"<pre><code>post_run_hook(*, round: int) -&gt; None\n</code></pre> <p>Should be called after we called the run method.</p> Source code in <code>codeclash/agents/player.py</code> <pre><code>def post_run_hook(self, *, round: int) -&gt; None:\n    \"\"\"Should be called after we called the run method.\"\"\"\n    self._commit()\n\n    # Write all changes to separate JSON file\n    self._write_changes_to_file(round=round)\n\n    if self.push:\n        for cmd in [\n            f\"git push origin {self._branch_name}\",\n            \"git push origin --tags\",\n        ]:\n            assert_zero_exit_code(self.environment.execute(cmd), logger=self.logger)\n        self.logger.info(f\"Pushed {self.name} commit history to remote repository (branch {self._branch_name})\")\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Given the observation / recap, update the codebase</p> Source code in <code>codeclash/agents/player.py</code> <pre><code>@abstractmethod\ndef run(self) -&gt; None:\n    \"\"\"Given the observation / recap, update the codebase\"\"\"\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata() -&gt; dict\n</code></pre> <p>Get metadata for the agent.</p> Source code in <code>codeclash/agents/player.py</code> <pre><code>def get_metadata(self) -&gt; dict:\n    \"\"\"Get metadata for the agent.\"\"\"\n    return self._metadata\n</code></pre>"},{"location":"reference/player/player/#codeclash.agents.player.Player.reset_and_apply_patch","title":"reset_and_apply_patch","text":"<pre><code>reset_and_apply_patch(patch: str, *, base_commit: str = '', filter_patch: bool = True) -&gt; None\n</code></pre> <p>Clean all uncommitted changes. If base_commit is provided, reset to that commit. Then apply the patch to the codebase.</p> Source code in <code>codeclash/agents/player.py</code> <pre><code>def reset_and_apply_patch(self, patch: str, *, base_commit: str = \"\", filter_patch: bool = True) -&gt; None:\n    \"\"\"Clean all uncommitted changes. If base_commit is provided, reset to that commit.\n    Then apply the patch to the codebase.\n    \"\"\"\n    # Need to clean before we copy over the patch (else it's gonna be removed by git clean)\n    self.logger.debug(\n        assert_zero_exit_code(self.environment.execute(f\"git reset --hard {base_commit} &amp;&amp; git clean -fd\"))\n    )\n\n    patch = filter_git_diff(patch) if filter_patch else patch\n\n    if not patch.strip():\n        self.logger.debug(\"No patch to apply, skipping\")\n        return\n\n    create_file_in_container(\n        container=self.environment,  # type: ignore\n        content=patch,\n        dest_path=\"tmp_patch.txt\",\n    )\n\n    commands = [\"git status\", \"git apply tmp_patch.txt\", \"rm -f tmp_patch.txt\"]\n    cmd = \" &amp;&amp; \".join(commands)\n    self.logger.debug(f\"Executing command: {cmd}\")\n    assert_zero_exit_code(self.environment.execute(cmd), logger=self.logger)\n</code></pre>"},{"location":"reference/tournament/pvp/","title":"PvP Tournament","text":"<p>Player-versus-player tournament where multiple agents compete head-to-head.</p>"},{"location":"reference/tournament/pvp/#overview","title":"Overview","text":"<p>PvP tournaments pit multiple agents against each other in competitive matches. Agents earn points by winning rounds, and the agent with the most cumulative points wins the tournament.</p>"},{"location":"reference/tournament/pvp/#tournament-format","title":"Tournament Format","text":"<ol> <li>Initialization: All agents start with clean codebases</li> <li>Round Loop: For each round:</li> <li>All agents update their code based on previous results</li> <li>Game is executed with all agents</li> <li>Points awarded based on performance</li> <li>Winner: Agent with highest cumulative score</li> </ol>"},{"location":"reference/tournament/pvp/#configuration","title":"Configuration","text":"<pre><code>game:\n  name: BattleCode\n  rounds: 15\n  sims_per_round: 3\n  timeout: 600\n\nplayers:\n  - name: Agent1\n    model: gpt-4-turbo\n    temperature: 0.7\n\n  - name: Agent2\n    model: claude-3-opus\n    temperature: 0.7\n\n  - name: Agent3\n    model: gpt-4\n    temperature: 0.5\n\ntournament:\n  keep_containers: false\n  push_to_remote: false\n</code></pre>"},{"location":"reference/tournament/pvp/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament","title":"codeclash.tournaments.pvp.PvpTournament","text":"<pre><code>PvpTournament(config: dict, *, output_dir: Path, cleanup: bool = False, push: bool = False, keep_containers: bool = False)\n</code></pre> <p>               Bases: <code>AbstractTournament</code></p> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def __init__(\n    self,\n    config: dict,\n    *,\n    output_dir: Path,\n    cleanup: bool = False,\n    push: bool = False,\n    keep_containers: bool = False,\n):\n    super().__init__(config, name=\"PvpTournament\", output_dir=output_dir)\n    if self.metadata_file.exists():\n        self.logger.critical(f\"Metadata file already exists: {self.metadata_file}\")\n        raise FileExistsError(f\"Metadata file already exists: {self.metadata_file}\")\n    self.cleanup_on_end = cleanup\n    self.game: CodeGame = get_game(\n        self.config,\n        tournament_id=self.tournament_id,\n        local_output_dir=self.local_output_dir,\n        keep_containers=keep_containers,\n    )\n    self.agents: list[Player] = []\n    for agent_conf in self.config[\"players\"]:\n        self.agents.append(self.get_agent(agent_conf, self.config[\"prompts\"], push=push))\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.cleanup_on_end","title":"cleanup_on_end  <code>instance-attribute</code>","text":"<pre><code>cleanup_on_end = cleanup\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.game","title":"game  <code>instance-attribute</code>","text":"<pre><code>game: CodeGame = get_game(config, tournament_id=tournament_id, local_output_dir=local_output_dir, keep_containers=keep_containers)\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.agents","title":"agents  <code>instance-attribute</code>","text":"<pre><code>agents: list[Player] = []\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.metadata_file","title":"metadata_file  <code>property</code>","text":"<pre><code>metadata_file: Path\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.rounds","title":"rounds  <code>property</code>","text":"<pre><code>rounds: int\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.transparent","title":"transparent  <code>property</code>","text":"<pre><code>transparent: bool\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata() -&gt; dict\n</code></pre> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def get_metadata(self) -&gt; dict:\n    # will be saved in end()\n    return {\n        **super().get_metadata(),\n        \"game\": self.game.get_metadata(),\n        \"agents\": [agent.get_metadata() for agent in self.agents],\n    }\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.get_agent","title":"get_agent","text":"<pre><code>get_agent(agent_config: dict, prompts: dict, push: bool) -&gt; Player\n</code></pre> <p>Create an agent with environment and game context.</p> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def get_agent(self, agent_config: dict, prompts: dict, push: bool) -&gt; Player:\n    \"\"\"Create an agent with environment and game context.\"\"\"\n    environment = self.game.get_environment(f\"{self.game.game_id}.{agent_config['name']}\")\n\n    game_context = GameContext(\n        id=self.game.game_id,\n        log_env=self.game.log_env,\n        log_local=self.game.log_local,\n        name=self.game.name,\n        player_id=agent_config[\"name\"],\n        prompts=prompts,\n        round=1,\n        rounds=self.rounds,\n        working_dir=str(DIR_WORK),\n    )\n\n    return get_agent(agent_config, game_context, environment, push=push)\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Main execution function that runs all rounds.</p> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Main execution function that runs all rounds.\"\"\"\n    try:\n        self.run_competition_phase(0)  # Initial round with identical codebases\n        for round_num in range(1, self.rounds + 1):\n            self.run_edit_phase(round_num)\n            self.run_competition_phase(round_num)\n        # Need to separately compress the last round, because\n        # in run_edit_phase we always only compress the previous round\n        self._compress_round_folder(self.rounds)\n    finally:\n        self.end()\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.run_competition_phase","title":"run_competition_phase","text":"<pre><code>run_competition_phase(round_num: int) -&gt; None\n</code></pre> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def run_competition_phase(self, round_num: int) -&gt; None:\n    # Run the game round and get results\n    stats = self.game.run_round(self.agents, round_num)\n    self.logger.info(stats)\n\n    self._metadata.setdefault(\"round_stats\", {})[round_num] = stats.to_dict()\n\n    # Create directory for round logs\n    (self.game.log_local / \"rounds\" / str(round_num)).mkdir(parents=True, exist_ok=True)\n\n    # Write logs to file\n    results_file = self.game.log_local / \"rounds\" / str(round_num) / FILE_RESULTS\n    results_file.write_text(json.dumps(stats.to_dict(), indent=2))\n\n    self._save()\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.run_edit_phase","title":"run_edit_phase","text":"<pre><code>run_edit_phase(round_num: int) -&gt; None\n</code></pre> <p>Execute a single training round.</p> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def run_edit_phase(self, round_num: int) -&gt; None:\n    \"\"\"Execute a single training round.\"\"\"\n    # Copy log to agent environments\n    for agent in self.agents:\n        self.logger.info(f\"Copying round {round_num - 1} log(s) to {agent.name}'s container...\")\n        copy_to_container(\n            agent.environment,\n            self.game.log_local / \"rounds\" / str(round_num - 1),\n            DIR_LOGS / \"rounds\" / str(round_num - 1),\n        )\n    self._compress_round_folder(round_num - 1)\n\n    if self.transparent:\n        # Copy agent's codebase to all other agents\n        self.logger.info(\"Transparent mode enabled: copying codebases between agents...\")\n        for idx in range(len(self.agents)):\n            agent = self.agents[idx]\n            opponents = [a for j, a in enumerate(self.agents) if j != idx]\n            self.logger.info(f\"Copying {agent.name}'s codebase to other agents...\")\n            for opp in opponents:\n                copy_between_containers(\n                    agent.environment,\n                    opp.environment,\n                    agent.environment.config.cwd,\n                    f\"/{OPPONENT_CODEBASES_DIR_NAME}/{agent.name}/\",\n                )\n\n    with ThreadPoolExecutor() as executor:\n        futures = [executor.submit(self.run_agent, agent, round_num) for agent in self.agents]\n        for future in futures:\n            try:\n                future.result()\n            except Exception as e:\n                self.logger.critical(f\"Agent execution failed: {e}\", exc_info=True)\n                raise\n\n    self._save()\n    self.logger.info(\"Round completed.\")\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.run_agent","title":"run_agent","text":"<pre><code>run_agent(agent: Player, round_num: int) -&gt; None\n</code></pre> <p>Run a single agent for the current round.</p> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def run_agent(self, agent: Player, round_num: int) -&gt; None:\n    \"\"\"Run a single agent for the current round.\"\"\"\n    agent.pre_run_hook(new_round=round_num)\n    agent.run()\n    agent.post_run_hook(round=round_num)\n</code></pre>"},{"location":"reference/tournament/pvp/#codeclash.tournaments.pvp.PvpTournament.end","title":"end","text":"<pre><code>end() -&gt; None\n</code></pre> <p>Save output files, clean up game resources and push agents if requested.</p> Source code in <code>codeclash/tournaments/pvp.py</code> <pre><code>def end(self) -&gt; None:\n    \"\"\"Save output files, clean up game resources and push agents if requested.\"\"\"\n    self._save()\n    self.game.end(self.cleanup_on_end)\n</code></pre>"},{"location":"reference/tournament/single_player/","title":"SinglePlayer Tournament","text":""},{"location":"reference/tournament/single_player/#overview","title":"Overview","text":"<p><code>SinglePlayer</code> mode has an agent play against itself.</p>"},{"location":"reference/tournament/single_player/#tournament-format","title":"Tournament Format","text":"<ol> <li>Initialization: Agent starts with clean codebase</li> <li>Round Loop: For each round:</li> <li>Agent updates code</li> <li>Challenge/benchmark is executed</li> <li>Performance metrics recorded</li> <li>Evaluation: Agent scored on cumulative performance</li> </ol>"},{"location":"reference/tournament/single_player/#configuration","title":"Configuration","text":"<pre><code>game:\n  name: HuskyBench\n  rounds: 10\n\n\nplayers:\n  - name: SoloAgent\n    model: gpt-4-turbo\n    temperature: 0.7\n</code></pre>"},{"location":"reference/tournament/single_player/#running-a-singleplayer-tournament","title":"Running a SinglePlayer Tournament","text":"<pre><code>python main_single_player.py configs/single_player/config.yaml\n</code></pre>"},{"location":"reference/tournament/single_player/#implementation","title":"Implementation","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining","title":"codeclash.tournaments.single_player.SinglePlayerTraining","text":"<pre><code>SinglePlayerTraining(config: dict, *, output_dir: Path, cleanup: bool = False, keep_containers: bool = False)\n</code></pre> <p>               Bases: <code>AbstractTournament</code></p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def __init__(self, config: dict, *, output_dir: Path, cleanup: bool = False, keep_containers: bool = False):\n    super().__init__(config, name=\"SinglePlayerTraining\", output_dir=output_dir)\n    self.cleanup_on_end = cleanup\n    self.game: CodeGame = get_game(\n        self.config,\n        tournament_id=self.tournament_id,\n        local_output_dir=self.local_output_dir,\n        keep_containers=keep_containers,\n    )\n    self.agent: Player = self.get_agent(self.config[\"player\"], round=1)\n    mirror_agent_config = copy.deepcopy(self.config[\"player\"])\n    mirror_agent_config[\"name\"] = \"mirror\"\n    self.mirror_agent: Player = self.get_agent(mirror_agent_config, round=0)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.cleanup_on_end","title":"cleanup_on_end  <code>instance-attribute</code>","text":"<pre><code>cleanup_on_end = cleanup\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.game","title":"game  <code>instance-attribute</code>","text":"<pre><code>game: CodeGame = get_game(config, tournament_id=tournament_id, local_output_dir=local_output_dir, keep_containers=keep_containers)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.agent","title":"agent  <code>instance-attribute</code>","text":"<pre><code>agent: Player = get_agent(config['player'], round=1)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.mirror_agent","title":"mirror_agent  <code>instance-attribute</code>","text":"<pre><code>mirror_agent: Player = get_agent(mirror_agent_config, round=0)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.rounds","title":"rounds  <code>property</code>","text":"<pre><code>rounds: int\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata() -&gt; dict\n</code></pre> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def get_metadata(self) -&gt; dict:\n    return {\n        **super().get_metadata(),\n        \"game\": self.game.get_metadata(),\n        \"agents\": [self.agent.get_metadata(), self.mirror_agent.get_metadata()],\n    }\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.get_game_context","title":"get_game_context","text":"<pre><code>get_game_context(agent_config: dict, *, round: int) -&gt; GameContext\n</code></pre> <p>Create a game context for an agent.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def get_game_context(self, agent_config: dict, *, round: int) -&gt; GameContext:\n    \"\"\"Create a game context for an agent.\"\"\"\n    return GameContext(\n        id=self.game.game_id,\n        log_env=self.game.log_env,\n        log_local=self.game.log_local,\n        name=self.game.name,\n        player_id=agent_config[\"name\"],\n        prompts=self.config[\"prompts\"],\n        round=round,\n        rounds=self.rounds,\n        working_dir=str(DIR_WORK),\n    )\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.get_agent","title":"get_agent","text":"<pre><code>get_agent(agent_config: dict, round: int) -&gt; Player\n</code></pre> <p>Create an agent with environment and game context.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def get_agent(self, agent_config: dict, round: int) -&gt; Player:\n    \"\"\"Create an agent with environment and game context.\"\"\"\n    environment = self.game.get_environment(f\"{self.game.game_id}.{agent_config['name']}\")\n    game_context = self.get_game_context(agent_config, round=round)\n    return get_agent(agent_config, game_context, environment)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.get_dummy_agent","title":"get_dummy_agent","text":"<pre><code>get_dummy_agent(player_config: dict) -&gt; Player\n</code></pre> <p>Create a dummy agent that does nothing.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def get_dummy_agent(self, player_config: dict) -&gt; Player:\n    \"\"\"Create a dummy agent that does nothing.\"\"\"\n    return Dummy(\n        player_config,\n        environment=self.game.get_environment(f\"{self.game.game_id}.dummy\"),\n        game_context=self.get_game_context(player_config, round=0),\n    )\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Main execution function that runs all rounds.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def run(self):\n    \"\"\"Main execution function that runs all rounds.\"\"\"\n    try:\n        for round_num in range(1, self.rounds + 1):\n            self.run_training_round(round_num)\n        if self.config[\"tournament\"][\"evaluate_matrix\"]:\n            self.evaluate()\n    finally:\n        self.end()\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.run_training_round","title":"run_training_round","text":"<pre><code>run_training_round(round_num: int) -&gt; None\n</code></pre> <p>Execute a single training round, i.e., run the game, then run the agent.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def run_training_round(self, round_num: int) -&gt; None:\n    \"\"\"Execute a single training round, i.e., run the game, then run the agent.\"\"\"\n    # Run the game round and get results\n    stats = self.game.run_round([self.agent, self.mirror_agent], round_num)\n    self.logger.info(stats)\n    self._metadata.setdefault(\"round_stats\", {})[round_num] = stats.to_dict()\n\n    # Write log to file\n    results_file = self.game.log_local / \"rounds\" / str(round_num) / FILE_RESULTS\n    results_file.write_text(json.dumps(stats.to_dict(), indent=2))\n\n    # Copy log to main agent environment only\n    self.logger.info(f\"Copying round {round_num} log(s) to {self.agent.name}'s container...\")\n    copy_to_container(\n        self.agent.environment,\n        self.game.log_local / \"rounds\" / str(round_num),\n        f\"logs/rounds/{round_num}/\",\n    )\n\n    self.run_main_agent(round_num)\n    mirror_agent_state = round_num - 1 if round_num &gt; 1 else 0\n    self.set_mirror_state_to_round(mirror_agent_state)\n\n    self._save()\n\n    self.logger.info(\"Round completed.\")\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.run_main_agent","title":"run_main_agent","text":"<pre><code>run_main_agent(round_num: int)\n</code></pre> <p>Run the main agent for the current round.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def run_main_agent(self, round_num: int):\n    \"\"\"Run the main agent for the current round.\"\"\"\n    self.agent.pre_run_hook(new_round=round_num)\n    self.agent.run()\n    self.agent.post_run_hook(round=round_num)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.set_mirror_state_to_round","title":"set_mirror_state_to_round","text":"<pre><code>set_mirror_state_to_round(round_num: int)\n</code></pre> <p>Update mirror agent's codebase with the main agent's changes.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def set_mirror_state_to_round(self, round_num: int):\n    \"\"\"Update mirror agent's codebase with the main agent's changes.\"\"\"\n    full_diff = self._get_round_diff(self.agent.name, round_num)\n    full_diff = filter_git_diff(full_diff)\n    self.mirror_agent.reset_and_apply_patch(full_diff)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.end","title":"end","text":"<pre><code>end()\n</code></pre> <p>Clean up game resources.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def end(self):\n    \"\"\"Clean up game resources.\"\"\"\n    self._save()\n    self.game.end(self.cleanup_on_end)\n</code></pre>"},{"location":"reference/tournament/single_player/#codeclash.tournaments.single_player.SinglePlayerTraining.evaluate","title":"evaluate","text":"<pre><code>evaluate(n_repetitions: int = 3) -&gt; None\n</code></pre> <p>Evaluate the agent's performance by calculating the matrix of every round against each other.</p> Source code in <code>codeclash/tournaments/single_player.py</code> <pre><code>def evaluate(self, n_repetitions: int = 3) -&gt; None:\n    \"\"\"Evaluate the agent's performance by\n    calculating the matrix of every round against each other.\n    \"\"\"\n    p1_config = self.config[\"player\"].copy()\n    p1_config[\"name\"] = \"p1\"\n    p1 = self.get_dummy_agent(p1_config)\n\n    p2_config = self.config[\"player\"].copy()\n    p2_config[\"name\"] = \"p2\"\n    p2 = self.get_dummy_agent(p2_config)\n    matrix = {\n        p1_round: {p2_round: [] for p2_round in range(0, self.rounds + 1)} for p1_round in range(0, self.rounds + 1)\n    }\n    for p1_round in range(0, self.rounds + 1):\n        for p2_round in range(0, self.rounds + 1):\n            self.logger.info(f\"Evaluating agent at round {p1_round} against agent at round {p2_round}\")\n            p1_patch = self._get_round_diff(self.agent.name, p1_round)\n            p2_patch = self._get_round_diff(self.agent.name, p2_round)\n            p1.reset_and_apply_patch(p1_patch)\n            p2.reset_and_apply_patch(p2_patch)\n            for i_repetition in range(n_repetitions):\n                stats = self.game.run_round([p1, p2], round_num=int(f\"{p1_round}{p2_round}{i_repetition}\"))\n                self.logger.info(f\"Round {p1_round} vs {p2_round} repetition {i_repetition} winner: {stats.winner}\")\n                matrix[p1_round][p2_round].append(stats.winner)\n    self.logger.info(f\"Evaluation matrix: {matrix}\")\n    self._metadata.setdefault(\"evaluation\", {})[\"matrix\"] = matrix\n</code></pre>"},{"location":"reference/tournament/tournament/","title":"AbstractTournament","text":"<p>The base class for all tournament types in CodeClash.</p>"},{"location":"reference/tournament/tournament/#overview","title":"Overview","text":"<p>The <code>AbstractTournament</code> class provides:</p> <ul> <li>Tournament initialization and configuration</li> <li>Logging infrastructure</li> <li>Metadata collection</li> <li>Common utilities for tournament orchestration</li> </ul> <p>Specific tournament types (PvP, SinglePlayer) extend this class.</p>"},{"location":"reference/tournament/tournament/#tournament-structure","title":"Tournament Structure","text":""},{"location":"reference/tournament/tournament/#configuration","title":"Configuration","text":"<p>All tournaments are configured via YAML files:</p> <pre><code>game:\n  name: BattleCode\n  rounds: 10\n  sims_per_round: 3\n  timeout: 300\n\nplayers:\n  - name: Agent1\n    model: gpt-4\n  - name: Agent2\n    model: claude-3\n</code></pre>"},{"location":"reference/tournament/tournament/#output-directory-structure","title":"Output Directory Structure","text":"<pre><code>logs/\n\u2514\u2500\u2500 {tournament_id}/\n    \u251c\u2500\u2500 tournament.log          # Main tournament log\n    \u251c\u2500\u2500 game.log               # Game-specific log\n    \u251c\u2500\u2500 everything.log         # Combined log\n    \u251c\u2500\u2500 metadata.json          # Tournament metadata\n    \u251c\u2500\u2500 players/\n    \u2502   \u2514\u2500\u2500 {player_name}/\n    \u2502       \u251c\u2500\u2500 player.log\n    \u2502       \u2514\u2500\u2500 changes_r{N}.json\n    \u2514\u2500\u2500 rounds/\n        \u2514\u2500\u2500 {round_num}/\n            \u2514\u2500\u2500 game logs...\n</code></pre>"},{"location":"reference/tournament/tournament/#metadata","title":"Metadata","text":"<p>Tournament metadata is stored in <code>metadata.json</code>:</p> <pre><code>{\n  \"name\": \"pvp\",\n  \"tournament_id\": \"pvp.BattleCode.251104123456\",\n  \"created_timestamp\": 1730736896,\n  \"config\": {\n    \"game\": {...},\n    \"players\": [...]\n  }\n}\n</code></pre>"},{"location":"reference/tournament/tournament/#see-also","title":"See Also","text":"<ul> <li>PvP Tournament</li> <li>SinglePlayer Tournament</li> <li>CodeGame Base Class</li> <li>Player Base Class</li> </ul>"},{"location":"reference/tournament/tournament/#class-reference","title":"Class Reference","text":"bug_report Something broken/unclear? <p>Open an issue on GitHub!</p> help Open-ended discussions <p>Join our Slack!</p>"},{"location":"reference/tournament/tournament/#codeclash.tournaments.tournament.AbstractTournament","title":"codeclash.tournaments.tournament.AbstractTournament","text":"<pre><code>AbstractTournament(config: dict, *, name: str, output_dir: Path, **kwargs)\n</code></pre> Source code in <code>codeclash/tournaments/tournament.py</code> <pre><code>def __init__(self, config: dict, *, name: str, output_dir: Path, **kwargs):\n    self.config: dict = config\n    self.name: str = name\n    self.tournament_id: str = f\"{self.name}.{config['game']['name']}.{time.strftime('%y%m%d%H%M%S')}\"\n    self._output_dir: Path = output_dir\n    self._metadata: dict = {\n        \"name\": self.name,\n        \"tournament_id\": self.tournament_id,\n        \"config\": self.config,\n        \"created_timestamp\": int(time.time()),\n        \"aws\": get_aws_metadata(),\n    }\n    self.logger = get_logger(self.name, log_path=self.local_output_dir / \"tournament.log\", emoji=\"\ud83c\udfc6\")\n    add_root_file_handler(self.local_output_dir / \"everything.log\")\n</code></pre>"},{"location":"reference/tournament/tournament/#codeclash.tournaments.tournament.AbstractTournament.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config: dict = config\n</code></pre>"},{"location":"reference/tournament/tournament/#codeclash.tournaments.tournament.AbstractTournament.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"reference/tournament/tournament/#codeclash.tournaments.tournament.AbstractTournament.tournament_id","title":"tournament_id  <code>instance-attribute</code>","text":"<pre><code>tournament_id: str = f'{name}.{config['game']['name']}.{strftime('%y%m%d%H%M%S')}'\n</code></pre>"},{"location":"reference/tournament/tournament/#codeclash.tournaments.tournament.AbstractTournament.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = get_logger(name, log_path=local_output_dir / 'tournament.log', emoji='\ud83c\udfc6')\n</code></pre>"},{"location":"reference/tournament/tournament/#codeclash.tournaments.tournament.AbstractTournament.local_output_dir","title":"local_output_dir  <code>property</code>","text":"<pre><code>local_output_dir: Path\n</code></pre>"},{"location":"reference/tournament/tournament/#codeclash.tournaments.tournament.AbstractTournament.get_metadata","title":"get_metadata","text":"<pre><code>get_metadata() -&gt; dict\n</code></pre> Source code in <code>codeclash/tournaments/tournament.py</code> <pre><code>def get_metadata(self) -&gt; dict:\n    return self._metadata\n</code></pre>"}]}